   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"button.c"
  21              	.Ltext0:
  22              		.file 1 "../button.c"
 2979              		.align	2
 2981              	celda_poner_valor:
 2982              	.LFB1:
   1:../celda.h    **** 	/* guarda para evitar inclusiones mÃºltiples (include guard) */
   2:../celda.h    **** 	#ifndef CELDA_H
   3:../celda.h    **** 	#define CELDA_H
   4:../celda.h    **** 	
   5:../celda.h    **** 	#include <inttypes.h>
   6:../celda.h    **** 	
   7:../celda.h    **** 	/* Cada celda se codifica en 16 bits
   8:../celda.h    **** 	 * bits [15,7]: los 9 bits mÃ¡s significativos representan el vector de candidatos,
   9:../celda.h    **** 	 * si el bit 7 + valor - 1 estÃ¡ a 0, valor es candidato, 1 en caso contrario
  10:../celda.h    **** 	 * bit 6: no empleado
  11:../celda.h    **** 	 * bit 5: error
  12:../celda.h    **** 	 * bit 4: pista
  13:../celda.h    **** 	 * bits [3,0]: valor de la celda
  14:../celda.h    **** 	 */
  15:../celda.h    **** 	
  16:../celda.h    **** enum { BIT_CANDIDATOS = 7, BIT_NO_USADO = 6, BIT_ERROR = 5, BIT_PISTA = 4 };
  17:../celda.h    **** 	
  18:../celda.h    **** 	typedef uint16_t CELDA;
  19:../celda.h    **** 	
  20:../celda.h    **** 	/* *****************************************************************************
  21:../celda.h    **** 	 * elimina el candidato del valor almacenado en la celda indicada */
  22:../celda.h    **** 	__inline static void
  23:../celda.h    **** 	celda_eliminar_candidato(CELDA *celdaptr, uint8_t valor)
  24:../celda.h    **** 	{
  25:../celda.h    **** 		*celdaptr = *celdaptr | (0x0001 << (BIT_CANDIDATOS + valor - 1));
  26:../celda.h    **** 	}
  27:../celda.h    **** 	
  28:../celda.h    **** 	/* *****************************************************************************
  29:../celda.h    **** 	 * modifica el valor almacenado en la celda indicada */
  30:../celda.h    **** 	__inline static void
  31:../celda.h    **** 	celda_poner_valor(CELDA *celdaptr, uint8_t val)
  32:../celda.h    **** 	{
 2983              		.loc 17 32 0
 2984              		.cfi_startproc
 2985              		@ Function supports interworking.
 2986              		@ args = 0, pretend = 0, frame = 8
 2987              		@ frame_needed = 1, uses_anonymous_args = 0
 2988 0000 0DC0A0E1 		mov	ip, sp
 2989              	.LCFI0:
 2990              		.cfi_def_cfa_register 12
 2991 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2992 0008 04B04CE2 		sub	fp, ip, #4
 2993              		.cfi_offset 14, -8
 2994              		.cfi_offset 13, -12
 2995              		.cfi_offset 11, -16
 2996              	.LCFI1:
 2997              		.cfi_def_cfa 11, 4
 2998 000c 08D04DE2 		sub	sp, sp, #8
 2999 0010 10000BE5 		str	r0, [fp, #-16]
 3000 0014 0130A0E1 		mov	r3, r1
 3001 0018 11304BE5 		strb	r3, [fp, #-17]
  33:../celda.h    **** 		*celdaptr = (*celdaptr & 0xFFF0) | (val & 0x000F);
 3002              		.loc 17 33 0
 3003 001c 10301BE5 		ldr	r3, [fp, #-16]
 3004 0020 B030D3E1 		ldrh	r3, [r3, #0]
 3005 0024 0338A0E1 		mov	r3, r3, asl #16
 3006 0028 2338A0E1 		mov	r3, r3, lsr #16
 3007 002c 0F30C3E3 		bic	r3, r3, #15
 3008 0030 0338A0E1 		mov	r3, r3, asl #16
 3009 0034 2328A0E1 		mov	r2, r3, lsr #16
 3010 0038 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3011 003c 0338A0E1 		mov	r3, r3, asl #16
 3012 0040 2338A0E1 		mov	r3, r3, lsr #16
 3013 0044 0F3003E2 		and	r3, r3, #15
 3014 0048 0338A0E1 		mov	r3, r3, asl #16
 3015 004c 2338A0E1 		mov	r3, r3, lsr #16
 3016 0050 033082E1 		orr	r3, r2, r3
 3017 0054 0338A0E1 		mov	r3, r3, asl #16
 3018 0058 2338A0E1 		mov	r3, r3, lsr #16
 3019 005c 0338A0E1 		mov	r3, r3, asl #16
 3020 0060 2328A0E1 		mov	r2, r3, lsr #16
 3021 0064 10301BE5 		ldr	r3, [fp, #-16]
 3022 0068 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  34:../celda.h    **** 	}
 3023              		.loc 17 34 0
 3024 006c 0CD04BE2 		sub	sp, fp, #12
 3025 0070 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3026 0074 1EFF2FE1 		bx	lr
 3027              		.cfi_endproc
 3028              	.LFE1:
 3030              		.align	2
 3032              	celda_leer_valor:
 3033              	.LFB2:
  35:../celda.h    **** 	
  36:../celda.h    **** 	/* *****************************************************************************
  37:../celda.h    **** 	 * extrae el valor almacenado en los 16 bits de una celda */
  38:../celda.h    ****         __inline static uint8_t
  39:../celda.h    ****         celda_leer_valor(CELDA celda)
  40:../celda.h    ****         {
 3034              		.loc 17 40 0
 3035              		.cfi_startproc
 3036              		@ Function supports interworking.
 3037              		@ args = 0, pretend = 0, frame = 8
 3038              		@ frame_needed = 1, uses_anonymous_args = 0
 3039 0078 0DC0A0E1 		mov	ip, sp
 3040              	.LCFI2:
 3041              		.cfi_def_cfa_register 12
 3042 007c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3043 0080 04B04CE2 		sub	fp, ip, #4
 3044              		.cfi_offset 14, -8
 3045              		.cfi_offset 13, -12
 3046              		.cfi_offset 11, -16
 3047              	.LCFI3:
 3048              		.cfi_def_cfa 11, 4
 3049 0084 08D04DE2 		sub	sp, sp, #8
 3050 0088 0030A0E1 		mov	r3, r0
 3051 008c BE304BE1 		strh	r3, [fp, #-14]	@ movhi
  41:../celda.h    ****                 return (celda & 0x000F);
 3052              		.loc 17 41 0
 3053 0090 BE305BE1 		ldrh	r3, [fp, #-14]	@ movhi
 3054 0094 FF3003E2 		and	r3, r3, #255
 3055 0098 0F3003E2 		and	r3, r3, #15
 3056 009c FF3003E2 		and	r3, r3, #255
  42:../celda.h    ****         }
 3057              		.loc 17 42 0
 3058 00a0 0300A0E1 		mov	r0, r3
 3059 00a4 0CD04BE2 		sub	sp, fp, #12
 3060 00a8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3061 00ac 1EFF2FE1 		bx	lr
 3062              		.cfi_endproc
 3063              	.LFE2:
 3065              		.align	2
 3067              	celda_es_candidato:
 3068              	.LFB3:
  43:../celda.h    **** 
  44:../celda.h    ****         /* *****************************************************************************
  45:../celda.h    ****          * comprueba si el valor es candidato en la celda indicada */
  46:../celda.h    ****         __inline static int
  47:../celda.h    ****         celda_es_candidato(CELDA celda, uint8_t valor)
  48:../celda.h    ****         {
 3069              		.loc 17 48 0
 3070              		.cfi_startproc
 3071              		@ Function supports interworking.
 3072              		@ args = 0, pretend = 0, frame = 8
 3073              		@ frame_needed = 1, uses_anonymous_args = 0
 3074 00b0 0DC0A0E1 		mov	ip, sp
 3075              	.LCFI4:
 3076              		.cfi_def_cfa_register 12
 3077 00b4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3078 00b8 04B04CE2 		sub	fp, ip, #4
 3079              		.cfi_offset 14, -8
 3080              		.cfi_offset 13, -12
 3081              		.cfi_offset 11, -16
 3082              	.LCFI5:
 3083              		.cfi_def_cfa 11, 4
 3084 00bc 08D04DE2 		sub	sp, sp, #8
 3085 00c0 0020A0E1 		mov	r2, r0
 3086 00c4 0130A0E1 		mov	r3, r1
 3087 00c8 BE204BE1 		strh	r2, [fp, #-14]	@ movhi
 3088 00cc 0F304BE5 		strb	r3, [fp, #-15]
  49:../celda.h    ****                 return (celda & (0x0001 << (BIT_CANDIDATOS + valor - 1))) == 0;
 3089              		.loc 17 49 0
 3090 00d0 BE205BE1 		ldrh	r2, [fp, #-14]
 3091 00d4 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3092 00d8 063083E2 		add	r3, r3, #6
 3093 00dc 5233A0E1 		mov	r3, r2, asr r3
 3094 00e0 013003E2 		and	r3, r3, #1
 3095 00e4 000053E3 		cmp	r3, #0
 3096 00e8 0030A013 		movne	r3, #0
 3097 00ec 0130A003 		moveq	r3, #1
  50:../celda.h    ****         }
 3098              		.loc 17 50 0
 3099 00f0 0300A0E1 		mov	r0, r3
 3100 00f4 0CD04BE2 		sub	sp, fp, #12
 3101 00f8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3102 00fc 1EFF2FE1 		bx	lr
 3103              		.cfi_endproc
 3104              	.LFE3:
 3106              		.align	2
 3108              	celda_es_pista:
 3109              	.LFB4:
  51:../celda.h    **** 
  52:../celda.h    ****         /* *****************************************************************************
  53:../celda.h    ****          * comprueba si la celda es una pista */
  54:../celda.h    ****         __inline static int
  55:../celda.h    ****         celda_es_pista(CELDA celda)
  56:../celda.h    ****         {
 3110              		.loc 17 56 0
 3111              		.cfi_startproc
 3112              		@ Function supports interworking.
 3113              		@ args = 0, pretend = 0, frame = 8
 3114              		@ frame_needed = 1, uses_anonymous_args = 0
 3115 0100 0DC0A0E1 		mov	ip, sp
 3116              	.LCFI6:
 3117              		.cfi_def_cfa_register 12
 3118 0104 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3119 0108 04B04CE2 		sub	fp, ip, #4
 3120              		.cfi_offset 14, -8
 3121              		.cfi_offset 13, -12
 3122              		.cfi_offset 11, -16
 3123              	.LCFI7:
 3124              		.cfi_def_cfa 11, 4
 3125 010c 08D04DE2 		sub	sp, sp, #8
 3126 0110 0030A0E1 		mov	r3, r0
 3127 0114 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
  57:../celda.h    ****                 return (celda & (1 << BIT_PISTA)) != 0;
 3128              		.loc 17 57 0
 3129 0118 BE305BE1 		ldrh	r3, [fp, #-14]
 3130 011c 103003E2 		and	r3, r3, #16
 3131 0120 000053E3 		cmp	r3, #0
 3132 0124 0030A003 		moveq	r3, #0
 3133 0128 0130A013 		movne	r3, #1
  58:../celda.h    ****         }
 3134              		.loc 17 58 0
 3135 012c 0300A0E1 		mov	r0, r3
 3136 0130 0CD04BE2 		sub	sp, fp, #12
 3137 0134 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3138 0138 1EFF2FE1 		bx	lr
 3139              		.cfi_endproc
 3140              	.LFE4:
 3142              		.align	2
 3144              	celda_marcar_error:
 3145              	.LFB5:
  59:../celda.h    **** 
  60:../celda.h    ****         /* *****************************************************************************
  61:../celda.h    ****          * marca o limpia el bit de error de la celda */
  62:../celda.h    ****         __inline static void
  63:../celda.h    ****         celda_marcar_error(CELDA *celdaptr)
  64:../celda.h    ****         {
 3146              		.loc 17 64 0
 3147              		.cfi_startproc
 3148              		@ Function supports interworking.
 3149              		@ args = 0, pretend = 0, frame = 8
 3150              		@ frame_needed = 1, uses_anonymous_args = 0
 3151 013c 0DC0A0E1 		mov	ip, sp
 3152              	.LCFI8:
 3153              		.cfi_def_cfa_register 12
 3154 0140 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3155 0144 04B04CE2 		sub	fp, ip, #4
 3156              		.cfi_offset 14, -8
 3157              		.cfi_offset 13, -12
 3158              		.cfi_offset 11, -16
 3159              	.LCFI9:
 3160              		.cfi_def_cfa 11, 4
 3161 0148 08D04DE2 		sub	sp, sp, #8
 3162 014c 10000BE5 		str	r0, [fp, #-16]
  65:../celda.h    ****                 *celdaptr |= (1 << BIT_ERROR);
 3163              		.loc 17 65 0
 3164 0150 10301BE5 		ldr	r3, [fp, #-16]
 3165 0154 B030D3E1 		ldrh	r3, [r3, #0]
 3166 0158 203083E3 		orr	r3, r3, #32
 3167 015c 0338A0E1 		mov	r3, r3, asl #16
 3168 0160 2328A0E1 		mov	r2, r3, lsr #16
 3169 0164 10301BE5 		ldr	r3, [fp, #-16]
 3170 0168 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  66:../celda.h    ****         }
 3171              		.loc 17 66 0
 3172 016c 0CD04BE2 		sub	sp, fp, #12
 3173 0170 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3174 0174 1EFF2FE1 		bx	lr
 3175              		.cfi_endproc
 3176              	.LFE5:
 3178              		.align	2
 3180              	celda_limpiar_error:
 3181              	.LFB6:
  67:../celda.h    **** 
  68:../celda.h    ****         __inline static void
  69:../celda.h    ****         celda_limpiar_error(CELDA *celdaptr)
  70:../celda.h    ****         {
 3182              		.loc 17 70 0
 3183              		.cfi_startproc
 3184              		@ Function supports interworking.
 3185              		@ args = 0, pretend = 0, frame = 8
 3186              		@ frame_needed = 1, uses_anonymous_args = 0
 3187 0178 0DC0A0E1 		mov	ip, sp
 3188              	.LCFI10:
 3189              		.cfi_def_cfa_register 12
 3190 017c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3191 0180 04B04CE2 		sub	fp, ip, #4
 3192              		.cfi_offset 14, -8
 3193              		.cfi_offset 13, -12
 3194              		.cfi_offset 11, -16
 3195              	.LCFI11:
 3196              		.cfi_def_cfa 11, 4
 3197 0184 08D04DE2 		sub	sp, sp, #8
 3198 0188 10000BE5 		str	r0, [fp, #-16]
  71:../celda.h    ****                 *celdaptr &= ~(1 << BIT_ERROR);
 3199              		.loc 17 71 0
 3200 018c 10301BE5 		ldr	r3, [fp, #-16]
 3201 0190 B030D3E1 		ldrh	r3, [r3, #0]
 3202 0194 2030C3E3 		bic	r3, r3, #32
 3203 0198 0338A0E1 		mov	r3, r3, asl #16
 3204 019c 2328A0E1 		mov	r2, r3, lsr #16
 3205 01a0 10301BE5 		ldr	r3, [fp, #-16]
 3206 01a4 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  72:../celda.h    ****         }
 3207              		.loc 17 72 0
 3208 01a8 0CD04BE2 		sub	sp, fp, #12
 3209 01ac 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3210 01b0 1EFF2FE1 		bx	lr
 3211              		.cfi_endproc
 3212              	.LFE6:
 3214              		.bss
 3215              	estado_juego:
 3216 0000 00       		.space	1
 3217              	int_count:
 3218 0001 00       		.space	1
 3219              	fila:
 3220 0002 00       		.space	1
 3221              	columna:
 3222 0003 00       		.space	1
 3223              	valor:
 3224 0004 00       		.space	1
 3225              	valor_previo:
 3226 0005 00       		.space	1
 3227              	pantalla_mostrada:
 3228 0006 00       		.space	1
 3229              		.text
 3230              		.align	2
 3232              	boton_confirmado:
 3233              	.LFB7:
   1:../button.c   **** /*********************************************************************************************
   2:../button.c   **** * Fichero:      button.c
   3:../button.c   **** * Autor:
   4:../button.c   **** * Descrip:      Funciones de manejo de los pulsadores (EINT6-7)
   5:../button.c   **** * Version:
   6:../button.c   **** *********************************************************************************************/
   7:../button.c   **** 
   8:../button.c   **** /*--- ficheros de cabecera ---*/
   9:../button.c   **** #include "button.h"
  10:../button.c   **** #include "8led.h"
  11:../button.c   **** #include "cola.h"
  12:../button.c   **** #include "eventos.h"
  13:../button.c   **** #include "timer2.h"
  14:../button.c   **** #include "timer3.h"
  15:../button.c   **** #include "44blib.h"
  16:../button.c   **** #include "44b.h"
  17:../button.c   **** #include "def.h"
  18:../button.c   **** #include "sudoku_2025.h"
  19:../button.c   **** #include "lcd.h"
  20:../button.c   **** 
  21:../button.c   **** /*--- Variables del juego Sudoku ---*/
  22:../button.c   **** static volatile EstadoSudoku estado_juego = ESPERANDO_INICIO;
  23:../button.c   **** static volatile uint8_t int_count = 0;
  24:../button.c   **** static volatile uint8_t fila = 0;
  25:../button.c   **** static volatile uint8_t columna = 0;
  26:../button.c   **** static volatile uint8_t valor = 0;
  27:../button.c   **** static volatile uint8_t valor_previo = 0;  /* Para detectar modificación de valor */
  28:../button.c   **** static volatile uint8_t pantalla_mostrada = 0;  /* Flag para mostrar pantalla inicial solo una vez 
  29:../button.c   **** 
  30:../button.c   **** /* Declaración externa de la cuadrícula del juego */
  31:../button.c   **** extern CELDA (*cuadricula)[NUM_COLUMNAS];
  32:../button.c   **** extern int celdas_vacias;
  33:../button.c   **** 
  34:../button.c   **** /* Callback para recibir la confirmación de pulsaciones filtradas por el timer3 */
  35:../button.c   **** static void boton_confirmado(uint8_t boton_id) // MODIFICAR FUNCIONES ACTUALIZAR Y PROPAGAR SEGUN L
  36:../button.c   **** {
 3234              		.loc 1 36 0
 3235              		.cfi_startproc
 3236              		@ Function supports interworking.
 3237              		@ args = 0, pretend = 0, frame = 8
 3238              		@ frame_needed = 1, uses_anonymous_args = 0
 3239 01b4 0DC0A0E1 		mov	ip, sp
 3240              	.LCFI12:
 3241              		.cfi_def_cfa_register 12
 3242 01b8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3243 01bc 04B04CE2 		sub	fp, ip, #4
 3244              		.cfi_offset 14, -8
 3245              		.cfi_offset 13, -12
 3246              		.cfi_offset 11, -16
 3247              	.LCFI13:
 3248              		.cfi_def_cfa 11, 4
 3249 01c0 08D04DE2 		sub	sp, sp, #8
 3250 01c4 0030A0E1 		mov	r3, r0
 3251 01c8 0D304BE5 		strb	r3, [fp, #-13]
  37:../button.c   ****         cola_depuracion(timer2_count(), boton_id, estado_juego);
 3252              		.loc 1 37 0
 3253 01cc FEFFFFEB 		bl	timer2_count
 3254 01d0 0010A0E1 		mov	r1, r0
 3255 01d4 7C369FE5 		ldr	r3, .L35
 3256 01d8 0030D3E5 		ldrb	r3, [r3, #0]
 3257 01dc FF3003E2 		and	r3, r3, #255
 3258 01e0 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 3259 01e4 0100A0E1 		mov	r0, r1
 3260 01e8 0210A0E1 		mov	r1, r2
 3261 01ec 0320A0E1 		mov	r2, r3
 3262 01f0 FEFFFFEB 		bl	cola_depuracion
  38:../button.c   ****         
  39:../button.c   ****         switch (estado_juego)
 3263              		.loc 1 39 0
 3264 01f4 5C369FE5 		ldr	r3, .L35
 3265 01f8 0030D3E5 		ldrb	r3, [r3, #0]
 3266 01fc FF3003E2 		and	r3, r3, #255
 3267 0200 050053E3 		cmp	r3, #5
 3268 0204 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3269 0208 8F0100EA 		b	.L7
 3270              	.L15:
 3271 020c 24020000 		.word	.L9
 3272 0210 84020000 		.word	.L10
 3273 0214 34030000 		.word	.L11
 3274 0218 F4030000 		.word	.L12
 3275 021c 7C040000 		.word	.L13
 3276 0220 1C050000 		.word	.L14
 3277              	.L9:
  40:../button.c   ****         {
  41:../button.c   ****                 case ESPERANDO_INICIO:
  42:../button.c   ****                         /* Cualquier botón inicia el juego */
  43:../button.c   ****                         /* Calcular candidatos por primera vez */
  44:../button.c   ****                         celdas_vacias = candidatos_actualizar_all(cuadricula);
 3278              		.loc 1 44 0
 3279 0224 30369FE5 		ldr	r3, .L35+4
 3280 0228 003093E5 		ldr	r3, [r3, #0]
 3281 022c 0300A0E1 		mov	r0, r3
 3282 0230 FEFFFFEB 		bl	candidatos_actualizar_all
 3283 0234 0020A0E1 		mov	r2, r0
 3284 0238 20369FE5 		ldr	r3, .L35+8
 3285 023c 002083E5 		str	r2, [r3, #0]
  45:../button.c   ****                         
  46:../button.c   ****                         /* Dibujar el tablero del juego */
  47:../button.c   ****                         Sudoku_Dibujar_Tablero();
 3286              		.loc 1 47 0
 3287 0240 FEFFFFEB 		bl	Sudoku_Dibujar_Tablero
  48:../button.c   ****                         
  49:../button.c   ****                         /* Actualizar con los valores de la cuadrícula */
  50:../button.c   ****                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3288              		.loc 1 50 0
 3289 0244 10369FE5 		ldr	r3, .L35+4
 3290 0248 003093E5 		ldr	r3, [r3, #0]
 3291 024c 0300A0E1 		mov	r0, r3
 3292 0250 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
  51:../button.c   ****                         
  52:../button.c   ****                         /* Pasar a introducir fila */
  53:../button.c   ****                         estado_juego = INTRODUCIR_FILA;
 3293              		.loc 1 53 0
 3294 0254 FC359FE5 		ldr	r3, .L35
 3295 0258 0120A0E3 		mov	r2, #1
 3296 025c 0020C3E5 		strb	r2, [r3, #0]
  54:../button.c   ****                         int_count = 0;
 3297              		.loc 1 54 0
 3298 0260 FC359FE5 		ldr	r3, .L35+12
 3299 0264 0020A0E3 		mov	r2, #0
 3300 0268 0020C3E5 		strb	r2, [r3, #0]
  55:../button.c   ****                         D8Led_symbol(15);  /* Mostrar 'F' de Fila (índice 15 en el array Symbol) *
 3301              		.loc 1 55 0
 3302 026c 0F00A0E3 		mov	r0, #15
 3303 0270 FEFFFFEB 		bl	D8Led_symbol
  56:../button.c   ****                         pantalla_mostrada = 0;  /* Resetear flag para próxima partida */
 3304              		.loc 1 56 0
 3305 0274 EC359FE5 		ldr	r3, .L35+16
 3306 0278 0020A0E3 		mov	r2, #0
 3307 027c 0020C3E5 		strb	r2, [r3, #0]
  57:../button.c   ****                         break;
 3308              		.loc 1 57 0
 3309 0280 710100EA 		b	.L7
 3310              	.L10:
  58:../button.c   ****                 
  59:../button.c   ****                 case INTRODUCIR_FILA:
  60:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3311              		.loc 1 60 0
 3312 0284 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3313 0288 080053E3 		cmp	r3, #8
 3314 028c 1500001A 		bne	.L16
  61:../button.c   ****                         {
  62:../button.c   ****                                 /* Incrementar fila */
  63:../button.c   ****                                 int_count++;
 3315              		.loc 1 63 0
 3316 0290 CC359FE5 		ldr	r3, .L35+12
 3317 0294 0030D3E5 		ldrb	r3, [r3, #0]
 3318 0298 FF3003E2 		and	r3, r3, #255
 3319 029c 013083E2 		add	r3, r3, #1
 3320 02a0 FF2003E2 		and	r2, r3, #255
 3321 02a4 B8359FE5 		ldr	r3, .L35+12
 3322 02a8 0020C3E5 		strb	r2, [r3, #0]
  64:../button.c   ****                                 if (int_count > 9)
 3323              		.loc 1 64 0
 3324 02ac B0359FE5 		ldr	r3, .L35+12
 3325 02b0 0030D3E5 		ldrb	r3, [r3, #0]
 3326 02b4 FF3003E2 		and	r3, r3, #255
 3327 02b8 090053E3 		cmp	r3, #9
 3328 02bc 0200009A 		bls	.L17
  65:../button.c   ****                                 {
  66:../button.c   ****                                         int_count = 1;
 3329              		.loc 1 66 0
 3330 02c0 9C359FE5 		ldr	r3, .L35+12
 3331 02c4 0120A0E3 		mov	r2, #1
 3332 02c8 0020C3E5 		strb	r2, [r3, #0]
 3333              	.L17:
  67:../button.c   ****                                 }
  68:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3334              		.loc 1 68 0
 3335 02cc 90359FE5 		ldr	r3, .L35+12
 3336 02d0 0030D3E5 		ldrb	r3, [r3, #0]
 3337 02d4 FF3003E2 		and	r3, r3, #255
 3338 02d8 0F3003E2 		and	r3, r3, #15
 3339 02dc 0300A0E1 		mov	r0, r3
 3340 02e0 FEFFFFEB 		bl	D8Led_symbol
  69:../button.c   ****                         }
  70:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
  71:../button.c   ****                         {
  72:../button.c   ****                                 /* Confirmar fila y pasar a introducir columna */
  73:../button.c   ****                                 fila = int_count - 1;  /* Convertir a índice 0-8 */
  74:../button.c   ****                                 estado_juego = INTRODUCIR_COLUMNA;
  75:../button.c   ****                                 int_count = 0;
  76:../button.c   ****                                 D8Led_symbol(12);  /* Mostrar 'C' de Columna (índice 12 en el arra
  77:../button.c   ****                         }
  78:../button.c   ****                         break;
 3341              		.loc 1 78 0
 3342 02e4 580100EA 		b	.L7
 3343              	.L16:
  70:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3344              		.loc 1 70 0
 3345 02e8 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3346 02ec 040053E3 		cmp	r3, #4
 3347 02f0 5001001A 		bne	.L32
  73:../button.c   ****                                 fila = int_count - 1;  /* Convertir a índice 0-8 */
 3348              		.loc 1 73 0
 3349 02f4 68359FE5 		ldr	r3, .L35+12
 3350 02f8 0030D3E5 		ldrb	r3, [r3, #0]
 3351 02fc FF3003E2 		and	r3, r3, #255
 3352 0300 013043E2 		sub	r3, r3, #1
 3353 0304 FF2003E2 		and	r2, r3, #255
 3354 0308 5C359FE5 		ldr	r3, .L35+20
 3355 030c 0020C3E5 		strb	r2, [r3, #0]
  74:../button.c   ****                                 estado_juego = INTRODUCIR_COLUMNA;
 3356              		.loc 1 74 0
 3357 0310 40359FE5 		ldr	r3, .L35
 3358 0314 0220A0E3 		mov	r2, #2
 3359 0318 0020C3E5 		strb	r2, [r3, #0]
  75:../button.c   ****                                 int_count = 0;
 3360              		.loc 1 75 0
 3361 031c 40359FE5 		ldr	r3, .L35+12
 3362 0320 0020A0E3 		mov	r2, #0
 3363 0324 0020C3E5 		strb	r2, [r3, #0]
  76:../button.c   ****                                 D8Led_symbol(12);  /* Mostrar 'C' de Columna (índice 12 en el arra
 3364              		.loc 1 76 0
 3365 0328 0C00A0E3 		mov	r0, #12
 3366 032c FEFFFFEB 		bl	D8Led_symbol
 3367              		.loc 1 78 0
 3368 0330 450100EA 		b	.L7
 3369              	.L11:
  79:../button.c   ****                 
  80:../button.c   ****                 case INTRODUCIR_COLUMNA:
  81:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3370              		.loc 1 81 0
 3371 0334 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3372 0338 080053E3 		cmp	r3, #8
 3373 033c 1500001A 		bne	.L19
  82:../button.c   ****                         {
  83:../button.c   ****                                 /* Incrementar columna */
  84:../button.c   ****                                 int_count++;
 3374              		.loc 1 84 0
 3375 0340 1C359FE5 		ldr	r3, .L35+12
 3376 0344 0030D3E5 		ldrb	r3, [r3, #0]
 3377 0348 FF3003E2 		and	r3, r3, #255
 3378 034c 013083E2 		add	r3, r3, #1
 3379 0350 FF2003E2 		and	r2, r3, #255
 3380 0354 08359FE5 		ldr	r3, .L35+12
 3381 0358 0020C3E5 		strb	r2, [r3, #0]
  85:../button.c   ****                                 if (int_count > 9)
 3382              		.loc 1 85 0
 3383 035c 00359FE5 		ldr	r3, .L35+12
 3384 0360 0030D3E5 		ldrb	r3, [r3, #0]
 3385 0364 FF3003E2 		and	r3, r3, #255
 3386 0368 090053E3 		cmp	r3, #9
 3387 036c 0200009A 		bls	.L20
  86:../button.c   ****                                 {
  87:../button.c   ****                                         int_count = 1;
 3388              		.loc 1 87 0
 3389 0370 EC349FE5 		ldr	r3, .L35+12
 3390 0374 0120A0E3 		mov	r2, #1
 3391 0378 0020C3E5 		strb	r2, [r3, #0]
 3392              	.L20:
  88:../button.c   ****                                 }
  89:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3393              		.loc 1 89 0
 3394 037c E0349FE5 		ldr	r3, .L35+12
 3395 0380 0030D3E5 		ldrb	r3, [r3, #0]
 3396 0384 FF3003E2 		and	r3, r3, #255
 3397 0388 0F3003E2 		and	r3, r3, #15
 3398 038c 0300A0E1 		mov	r0, r3
 3399 0390 FEFFFFEB 		bl	D8Led_symbol
  90:../button.c   ****                         }
  91:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
  92:../button.c   ****                         {
  93:../button.c   ****                                 /* Confirmar columna y pasar a introducir valor */
  94:../button.c   ****                                 columna = int_count - 1;  /* Convertir a índice 0-8 */
  95:../button.c   ****                                 estado_juego = VERIFICAR_CELDA;
  96:../button.c   ****                                 int_count = 0;
  97:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
  98:../button.c   ****                         }
  99:../button.c   ****                         break;
 3400              		.loc 1 99 0
 3401 0394 2C0100EA 		b	.L7
 3402              	.L19:
  91:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3403              		.loc 1 91 0
 3404 0398 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3405 039c 040053E3 		cmp	r3, #4
 3406 03a0 2601001A 		bne	.L33
  94:../button.c   ****                                 columna = int_count - 1;  /* Convertir a índice 0-8 */
 3407              		.loc 1 94 0
 3408 03a4 B8349FE5 		ldr	r3, .L35+12
 3409 03a8 0030D3E5 		ldrb	r3, [r3, #0]
 3410 03ac FF3003E2 		and	r3, r3, #255
 3411 03b0 013043E2 		sub	r3, r3, #1
 3412 03b4 FF2003E2 		and	r2, r3, #255
 3413 03b8 B0349FE5 		ldr	r3, .L35+24
 3414 03bc 0020C3E5 		strb	r2, [r3, #0]
  95:../button.c   ****                                 estado_juego = VERIFICAR_CELDA;
 3415              		.loc 1 95 0
 3416 03c0 90349FE5 		ldr	r3, .L35
 3417 03c4 0320A0E3 		mov	r2, #3
 3418 03c8 0020C3E5 		strb	r2, [r3, #0]
  96:../button.c   ****                                 int_count = 0;
 3419              		.loc 1 96 0
 3420 03cc 90349FE5 		ldr	r3, .L35+12
 3421 03d0 0020A0E3 		mov	r2, #0
 3422 03d4 0020C3E5 		strb	r2, [r3, #0]
  97:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3423              		.loc 1 97 0
 3424 03d8 84349FE5 		ldr	r3, .L35+12
 3425 03dc 0030D3E5 		ldrb	r3, [r3, #0]
 3426 03e0 FF3003E2 		and	r3, r3, #255
 3427 03e4 0F3003E2 		and	r3, r3, #15
 3428 03e8 0300A0E1 		mov	r0, r3
 3429 03ec FEFFFFEB 		bl	D8Led_symbol
 3430              		.loc 1 99 0
 3431 03f0 150100EA 		b	.L7
 3432              	.L12:
 100:../button.c   ****                 
 101:../button.c   ****                 case VERIFICAR_CELDA:
 102:../button.c   ****                         /* Primero se verifica si la celda[fila][columna] no es una pista */
 103:../button.c   ****                         if (celda_es_pista(cuadricula[fila][columna]))
 3433              		.loc 1 103 0
 3434 03f4 60349FE5 		ldr	r3, .L35+4
 3435 03f8 002093E5 		ldr	r2, [r3, #0]
 3436 03fc 68349FE5 		ldr	r3, .L35+20
 3437 0400 0030D3E5 		ldrb	r3, [r3, #0]
 3438 0404 FF3003E2 		and	r3, r3, #255
 3439 0408 8332A0E1 		mov	r3, r3, asl #5
 3440 040c 032082E0 		add	r2, r2, r3
 3441 0410 58349FE5 		ldr	r3, .L35+24
 3442 0414 0030D3E5 		ldrb	r3, [r3, #0]
 3443 0418 FF3003E2 		and	r3, r3, #255
 3444 041c 8330A0E1 		mov	r3, r3, asl #1
 3445 0420 033082E0 		add	r3, r2, r3
 3446 0424 B030D3E1 		ldrh	r3, [r3, #0]
 3447 0428 0300A0E1 		mov	r0, r3
 3448 042c 33FFFFEB 		bl	celda_es_pista
 3449 0430 0030A0E1 		mov	r3, r0
 3450 0434 000053E3 		cmp	r3, #0
 3451 0438 0800000A 		beq	.L22
 104:../button.c   ****                         {
 105:../button.c   ****                                 // Se vuelve al estado INTRODUCIR_FILA
 106:../button.c   ****                                 estado_juego = INTRODUCIR_FILA;
 3452              		.loc 1 106 0
 3453 043c 14349FE5 		ldr	r3, .L35
 3454 0440 0120A0E3 		mov	r2, #1
 3455 0444 0020C3E5 		strb	r2, [r3, #0]
 107:../button.c   ****                                 int_count = 0;
 3456              		.loc 1 107 0
 3457 0448 14349FE5 		ldr	r3, .L35+12
 3458 044c 0020A0E3 		mov	r2, #0
 3459 0450 0020C3E5 		strb	r2, [r3, #0]
 108:../button.c   ****                                 D8Led_symbol(15);  /* Mostrar 'F' de Fila (índice 15 en el array S
 3460              		.loc 1 108 0
 3461 0454 0F00A0E3 		mov	r0, #15
 3462 0458 FEFFFFEB 		bl	D8Led_symbol
 109:../button.c   ****                         } 
 110:../button.c   ****                         else
 111:../button.c   ****                         {
 112:../button.c   ****                                 // Si no es pista, se pasa a INTRODUCIR_VALOR
 113:../button.c   ****                                 estado_juego = INTRODUCIR_VALOR;
 114:../button.c   ****                                 int_count = 0;
 115:../button.c   ****                         }
 116:../button.c   ****                         break;
 3463              		.loc 1 116 0
 3464 045c FA0000EA 		b	.L7
 3465              	.L22:
 113:../button.c   ****                                 estado_juego = INTRODUCIR_VALOR;
 3466              		.loc 1 113 0
 3467 0460 F0339FE5 		ldr	r3, .L35
 3468 0464 0420A0E3 		mov	r2, #4
 3469 0468 0020C3E5 		strb	r2, [r3, #0]
 114:../button.c   ****                                 int_count = 0;
 3470              		.loc 1 114 0
 3471 046c F0339FE5 		ldr	r3, .L35+12
 3472 0470 0020A0E3 		mov	r2, #0
 3473 0474 0020C3E5 		strb	r2, [r3, #0]
 3474              		.loc 1 116 0
 3475 0478 F30000EA 		b	.L7
 3476              	.L13:
 117:../button.c   ****                 
 118:../button.c   ****                 case INTRODUCIR_VALOR:
 119:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3477              		.loc 1 119 0
 3478 047c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3479 0480 080053E3 		cmp	r3, #8
 3480 0484 1500001A 		bne	.L24
 120:../button.c   ****                         {
 121:../button.c   ****                                 /* Incrementar valor */
 122:../button.c   ****                                 int_count++;
 3481              		.loc 1 122 0
 3482 0488 D4339FE5 		ldr	r3, .L35+12
 3483 048c 0030D3E5 		ldrb	r3, [r3, #0]
 3484 0490 FF3003E2 		and	r3, r3, #255
 3485 0494 013083E2 		add	r3, r3, #1
 3486 0498 FF2003E2 		and	r2, r3, #255
 3487 049c C0339FE5 		ldr	r3, .L35+12
 3488 04a0 0020C3E5 		strb	r2, [r3, #0]
 123:../button.c   ****                                 if (int_count > 9)
 3489              		.loc 1 123 0
 3490 04a4 B8339FE5 		ldr	r3, .L35+12
 3491 04a8 0030D3E5 		ldrb	r3, [r3, #0]
 3492 04ac FF3003E2 		and	r3, r3, #255
 3493 04b0 090053E3 		cmp	r3, #9
 3494 04b4 0200009A 		bls	.L25
 124:../button.c   ****                                 {
 125:../button.c   ****                                         int_count = 0;
 3495              		.loc 1 125 0
 3496 04b8 A4339FE5 		ldr	r3, .L35+12
 3497 04bc 0020A0E3 		mov	r2, #0
 3498 04c0 0020C3E5 		strb	r2, [r3, #0]
 3499              	.L25:
 126:../button.c   ****                                 }
 127:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3500              		.loc 1 127 0
 3501 04c4 98339FE5 		ldr	r3, .L35+12
 3502 04c8 0030D3E5 		ldrb	r3, [r3, #0]
 3503 04cc FF3003E2 		and	r3, r3, #255
 3504 04d0 0F3003E2 		and	r3, r3, #15
 3505 04d4 0300A0E1 		mov	r0, r3
 3506 04d8 FEFFFFEB 		bl	D8Led_symbol
 128:../button.c   ****                         }
 129:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 130:../button.c   ****                         {
 131:../button.c   ****                                 /* Confirmar valor e intentar escribir en la celda */
 132:../button.c   ****                                 valor = int_count;  /* Valor a escribir (0-9) */
 133:../button.c   ****                                 
 134:../button.c   ****                                 estado_juego = VERIFICAR_VALOR;
 135:../button.c   ****                                 int_count = 0;
 136:../button.c   ****                         }
 137:../button.c   ****                         break;
 3507              		.loc 1 137 0
 3508 04dc DA0000EA 		b	.L7
 3509              	.L24:
 129:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3510              		.loc 1 129 0
 3511 04e0 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3512 04e4 040053E3 		cmp	r3, #4
 3513 04e8 D600001A 		bne	.L34
 132:../button.c   ****                                 valor = int_count;  /* Valor a escribir (0-9) */
 3514              		.loc 1 132 0
 3515 04ec 70339FE5 		ldr	r3, .L35+12
 3516 04f0 0030D3E5 		ldrb	r3, [r3, #0]
 3517 04f4 FF2003E2 		and	r2, r3, #255
 3518 04f8 74339FE5 		ldr	r3, .L35+28
 3519 04fc 0020C3E5 		strb	r2, [r3, #0]
 134:../button.c   ****                                 estado_juego = VERIFICAR_VALOR;
 3520              		.loc 1 134 0
 3521 0500 50339FE5 		ldr	r3, .L35
 3522 0504 0520A0E3 		mov	r2, #5
 3523 0508 0020C3E5 		strb	r2, [r3, #0]
 135:../button.c   ****                                 int_count = 0;
 3524              		.loc 1 135 0
 3525 050c 50339FE5 		ldr	r3, .L35+12
 3526 0510 0020A0E3 		mov	r2, #0
 3527 0514 0020C3E5 		strb	r2, [r3, #0]
 3528              		.loc 1 137 0
 3529 0518 CB0000EA 		b	.L7
 3530              	.L14:
 138:../button.c   ****                 
 139:../button.c   ****                 case VERIFICAR_VALOR:
 140:../button.c   ****                         /* Guardar valor previo de la celda */
 141:../button.c   ****                         valor_previo = celda_leer_valor(cuadricula[fila][columna]);
 3531              		.loc 1 141 0
 3532 051c 38339FE5 		ldr	r3, .L35+4
 3533 0520 002093E5 		ldr	r2, [r3, #0]
 3534 0524 40339FE5 		ldr	r3, .L35+20
 3535 0528 0030D3E5 		ldrb	r3, [r3, #0]
 3536 052c FF3003E2 		and	r3, r3, #255
 3537 0530 8332A0E1 		mov	r3, r3, asl #5
 3538 0534 032082E0 		add	r2, r2, r3
 3539 0538 30339FE5 		ldr	r3, .L35+24
 3540 053c 0030D3E5 		ldrb	r3, [r3, #0]
 3541 0540 FF3003E2 		and	r3, r3, #255
 3542 0544 8330A0E1 		mov	r3, r3, asl #1
 3543 0548 033082E0 		add	r3, r2, r3
 3544 054c B030D3E1 		ldrh	r3, [r3, #0]
 3545 0550 0300A0E1 		mov	r0, r3
 3546 0554 C7FEFFEB 		bl	celda_leer_valor
 3547 0558 0030A0E1 		mov	r3, r0
 3548 055c 0320A0E1 		mov	r2, r3
 3549 0560 10339FE5 		ldr	r3, .L35+32
 3550 0564 0020C3E5 		strb	r2, [r3, #0]
 142:../button.c   ****                         
 143:../button.c   ****                         if (valor == 0)
 3551              		.loc 1 143 0
 3552 0568 04339FE5 		ldr	r3, .L35+28
 3553 056c 0030D3E5 		ldrb	r3, [r3, #0]
 3554 0570 FF3003E2 		and	r3, r3, #255
 3555 0574 000053E3 		cmp	r3, #0
 3556 0578 3200001A 		bne	.L27
 144:../button.c   ****                         {
 145:../button.c   ****                                 /* Valor 0 = borrar -> pasar a BORRAR_VALOR */
 146:../button.c   ****                                 /* Borrar el valor de la celda */
 147:../button.c   ****                                 celda_limpiar_error(&cuadricula[fila][columna]);
 3557              		.loc 1 147 0
 3558 057c D8329FE5 		ldr	r3, .L35+4
 3559 0580 003093E5 		ldr	r3, [r3, #0]
 3560 0584 0320A0E1 		mov	r2, r3
 3561 0588 DC329FE5 		ldr	r3, .L35+20
 3562 058c 0030D3E5 		ldrb	r3, [r3, #0]
 3563 0590 FF3003E2 		and	r3, r3, #255
 3564 0594 0312A0E1 		mov	r1, r3, asl #4
 3565 0598 D0329FE5 		ldr	r3, .L35+24
 3566 059c 0030D3E5 		ldrb	r3, [r3, #0]
 3567 05a0 FF3003E2 		and	r3, r3, #255
 3568 05a4 033081E0 		add	r3, r1, r3
 3569 05a8 8330A0E1 		mov	r3, r3, asl #1
 3570 05ac 033082E0 		add	r3, r2, r3
 3571 05b0 0300A0E1 		mov	r0, r3
 3572 05b4 EFFEFFEB 		bl	celda_limpiar_error
 148:../button.c   ****                                 celda_poner_valor(&cuadricula[fila][columna], 0);
 3573              		.loc 1 148 0
 3574 05b8 9C329FE5 		ldr	r3, .L35+4
 3575 05bc 003093E5 		ldr	r3, [r3, #0]
 3576 05c0 0320A0E1 		mov	r2, r3
 3577 05c4 A0329FE5 		ldr	r3, .L35+20
 3578 05c8 0030D3E5 		ldrb	r3, [r3, #0]
 3579 05cc FF3003E2 		and	r3, r3, #255
 3580 05d0 0312A0E1 		mov	r1, r3, asl #4
 3581 05d4 94329FE5 		ldr	r3, .L35+24
 3582 05d8 0030D3E5 		ldrb	r3, [r3, #0]
 3583 05dc FF3003E2 		and	r3, r3, #255
 3584 05e0 033081E0 		add	r3, r1, r3
 3585 05e4 8330A0E1 		mov	r3, r3, asl #1
 3586 05e8 033082E0 		add	r3, r2, r3
 3587 05ec 0300A0E1 		mov	r0, r3
 3588 05f0 0010A0E3 		mov	r1, #0
 3589 05f4 81FEFFEB 		bl	celda_poner_valor
 149:../button.c   ****                                 
 150:../button.c   ****                                 /* Al borrar un valor, hay que recalcular todos los candidatos */
 151:../button.c   ****                                 celdas_vacias = candidatos_actualizar_all(cuadricula);
 3590              		.loc 1 151 0
 3591 05f8 5C329FE5 		ldr	r3, .L35+4
 3592 05fc 003093E5 		ldr	r3, [r3, #0]
 3593 0600 0300A0E1 		mov	r0, r3
 3594 0604 FEFFFFEB 		bl	candidatos_actualizar_all
 3595 0608 0020A0E1 		mov	r2, r0
 3596 060c 4C329FE5 		ldr	r3, .L35+8
 3597 0610 002083E5 		str	r2, [r3, #0]
 152:../button.c   ****                                 
 153:../button.c   ****                                 /* Actualizar la visualización del tablero */
 154:../button.c   ****                                 Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3598              		.loc 1 154 0
 3599 0614 40329FE5 		ldr	r3, .L35+4
 3600 0618 003093E5 		ldr	r3, [r3, #0]
 3601 061c 0300A0E1 		mov	r0, r3
 3602 0620 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 155:../button.c   ****                                 
 156:../button.c   ****                                 /* Volver a introducir fila */
 157:../button.c   ****                                 estado_juego = INTRODUCIR_FILA;
 3603              		.loc 1 157 0
 3604 0624 2C329FE5 		ldr	r3, .L35
 3605 0628 0120A0E3 		mov	r2, #1
 3606 062c 0020C3E5 		strb	r2, [r3, #0]
 158:../button.c   ****                                 int_count = 0;
 3607              		.loc 1 158 0
 3608 0630 2C329FE5 		ldr	r3, .L35+12
 3609 0634 0020A0E3 		mov	r2, #0
 3610 0638 0020C3E5 		strb	r2, [r3, #0]
 159:../button.c   ****                                 D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 3611              		.loc 1 159 0
 3612 063c 0F00A0E3 		mov	r0, #15
 3613 0640 FEFFFFEB 		bl	D8Led_symbol
 160:../button.c   ****                                 break;
 3614              		.loc 1 160 0
 3615 0644 800000EA 		b	.L7
 3616              	.L27:
 161:../button.c   ****                         }
 162:../button.c   ****                         else
 163:../button.c   ****                         {
 164:../button.c   ****                                 /* Verificar si el valor es candidato */
 165:../button.c   ****                                 if (celda_es_candidato(cuadricula[fila][columna], valor))
 3617              		.loc 1 165 0
 3618 0648 0C329FE5 		ldr	r3, .L35+4
 3619 064c 002093E5 		ldr	r2, [r3, #0]
 3620 0650 14329FE5 		ldr	r3, .L35+20
 3621 0654 0030D3E5 		ldrb	r3, [r3, #0]
 3622 0658 FF3003E2 		and	r3, r3, #255
 3623 065c 8332A0E1 		mov	r3, r3, asl #5
 3624 0660 032082E0 		add	r2, r2, r3
 3625 0664 04329FE5 		ldr	r3, .L35+24
 3626 0668 0030D3E5 		ldrb	r3, [r3, #0]
 3627 066c FF3003E2 		and	r3, r3, #255
 3628 0670 8330A0E1 		mov	r3, r3, asl #1
 3629 0674 033082E0 		add	r3, r2, r3
 3630 0678 B020D3E1 		ldrh	r2, [r3, #0]
 3631 067c F0319FE5 		ldr	r3, .L35+28
 3632 0680 0030D3E5 		ldrb	r3, [r3, #0]
 3633 0684 FF3003E2 		and	r3, r3, #255
 3634 0688 0200A0E1 		mov	r0, r2
 3635 068c 0310A0E1 		mov	r1, r3
 3636 0690 86FEFFEB 		bl	celda_es_candidato
 3637 0694 0030A0E1 		mov	r3, r0
 3638 0698 000053E3 		cmp	r3, #0
 3639 069c 4700000A 		beq	.L28
 166:../button.c   ****                                 {
 167:../button.c   ****                                         /* Es candidato: escribir el valor en la celda */
 168:../button.c   ****                                         celda_limpiar_error(&cuadricula[fila][columna]);
 3640              		.loc 1 168 0
 3641 06a0 B4319FE5 		ldr	r3, .L35+4
 3642 06a4 003093E5 		ldr	r3, [r3, #0]
 3643 06a8 0320A0E1 		mov	r2, r3
 3644 06ac B8319FE5 		ldr	r3, .L35+20
 3645 06b0 0030D3E5 		ldrb	r3, [r3, #0]
 3646 06b4 FF3003E2 		and	r3, r3, #255
 3647 06b8 0312A0E1 		mov	r1, r3, asl #4
 3648 06bc AC319FE5 		ldr	r3, .L35+24
 3649 06c0 0030D3E5 		ldrb	r3, [r3, #0]
 3650 06c4 FF3003E2 		and	r3, r3, #255
 3651 06c8 033081E0 		add	r3, r1, r3
 3652 06cc 8330A0E1 		mov	r3, r3, asl #1
 3653 06d0 033082E0 		add	r3, r2, r3
 3654 06d4 0300A0E1 		mov	r0, r3
 3655 06d8 A6FEFFEB 		bl	celda_limpiar_error
 169:../button.c   ****                                         celda_poner_valor(&cuadricula[fila][columna], valor);
 3656              		.loc 1 169 0
 3657 06dc 78319FE5 		ldr	r3, .L35+4
 3658 06e0 003093E5 		ldr	r3, [r3, #0]
 3659 06e4 0320A0E1 		mov	r2, r3
 3660 06e8 7C319FE5 		ldr	r3, .L35+20
 3661 06ec 0030D3E5 		ldrb	r3, [r3, #0]
 3662 06f0 FF3003E2 		and	r3, r3, #255
 3663 06f4 0312A0E1 		mov	r1, r3, asl #4
 3664 06f8 70319FE5 		ldr	r3, .L35+24
 3665 06fc 0030D3E5 		ldrb	r3, [r3, #0]
 3666 0700 FF3003E2 		and	r3, r3, #255
 3667 0704 033081E0 		add	r3, r1, r3
 3668 0708 8330A0E1 		mov	r3, r3, asl #1
 3669 070c 032082E0 		add	r2, r2, r3
 3670 0710 5C319FE5 		ldr	r3, .L35+28
 3671 0714 0030D3E5 		ldrb	r3, [r3, #0]
 3672 0718 FF3003E2 		and	r3, r3, #255
 3673 071c 0200A0E1 		mov	r0, r2
 3674 0720 0310A0E1 		mov	r1, r3
 3675 0724 35FEFFEB 		bl	celda_poner_valor
 170:../button.c   ****                                         
 171:../button.c   ****                                         /* Decidir si propagar o actualizar según el caso */
 172:../button.c   ****                                         if (valor_previo != 0)
 3676              		.loc 1 172 0
 3677 0728 48319FE5 		ldr	r3, .L35+32
 3678 072c 0030D3E5 		ldrb	r3, [r3, #0]
 3679 0730 FF3003E2 		and	r3, r3, #255
 3680 0734 000053E3 		cmp	r3, #0
 3681 0738 0700000A 		beq	.L29
 173:../button.c   ****                                         {
 174:../button.c   ****                                                 /* Se modificó un valor previo -> recalcular todo 
 175:../button.c   ****                                                 celdas_vacias = candidatos_actualizar_all(cuadricul
 3682              		.loc 1 175 0
 3683 073c 18319FE5 		ldr	r3, .L35+4
 3684 0740 003093E5 		ldr	r3, [r3, #0]
 3685 0744 0300A0E1 		mov	r0, r3
 3686 0748 FEFFFFEB 		bl	candidatos_actualizar_all
 3687 074c 0020A0E1 		mov	r2, r0
 3688 0750 08319FE5 		ldr	r3, .L35+8
 3689 0754 002083E5 		str	r2, [r3, #0]
 3690 0758 0B0000EA 		b	.L30
 3691              	.L29:
 176:../button.c   ****                                         }
 177:../button.c   ****                                         else
 178:../button.c   ****                                         {
 179:../button.c   ****                                                 /* Celda vacía -> solo propagar el nuevo valor */
 180:../button.c   ****                                                 candidatos_propagar_arm(cuadricula, fila, columna);
 3692              		.loc 1 180 0
 3693 075c F8309FE5 		ldr	r3, .L35+4
 3694 0760 001093E5 		ldr	r1, [r3, #0]
 3695 0764 00319FE5 		ldr	r3, .L35+20
 3696 0768 0030D3E5 		ldrb	r3, [r3, #0]
 3697 076c FF2003E2 		and	r2, r3, #255
 3698 0770 F8309FE5 		ldr	r3, .L35+24
 3699 0774 0030D3E5 		ldrb	r3, [r3, #0]
 3700 0778 FF3003E2 		and	r3, r3, #255
 3701 077c 0100A0E1 		mov	r0, r1
 3702 0780 0210A0E1 		mov	r1, r2
 3703 0784 0320A0E1 		mov	r2, r3
 3704 0788 FEFFFFEB 		bl	candidatos_propagar_arm
 3705              	.L30:
 181:../button.c   ****                                         }
 182:../button.c   ****                                         
 183:../button.c   ****                                         /* Actualizar la visualización del tablero */
 184:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3706              		.loc 1 184 0
 3707 078c C8309FE5 		ldr	r3, .L35+4
 3708 0790 003093E5 		ldr	r3, [r3, #0]
 3709 0794 0300A0E1 		mov	r0, r3
 3710 0798 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 185:../button.c   ****                                         
 186:../button.c   ****                                         /* Volver a introducir fila */
 187:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 3711              		.loc 1 187 0
 3712 079c B4309FE5 		ldr	r3, .L35
 3713 07a0 0120A0E3 		mov	r2, #1
 3714 07a4 0020C3E5 		strb	r2, [r3, #0]
 188:../button.c   ****                                         int_count = 0;
 3715              		.loc 1 188 0
 3716 07a8 B4309FE5 		ldr	r3, .L35+12
 3717 07ac 0020A0E3 		mov	r2, #0
 3718 07b0 0020C3E5 		strb	r2, [r3, #0]
 189:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 3719              		.loc 1 189 0
 3720 07b4 0F00A0E3 		mov	r0, #15
 3721 07b8 FEFFFFEB 		bl	D8Led_symbol
 190:../button.c   ****                                 }
 191:../button.c   ****                                 else
 192:../button.c   ****                                 {
 193:../button.c   ****                                         /* No es candidato: marcar error y mostrar 'E' */
 194:../button.c   ****                                         celda_marcar_error(&cuadricula[fila][columna]);
 195:../button.c   ****                                         
 196:../button.c   ****                                         /* Actualizar la visualización del tablero */
 197:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 198:../button.c   ****                                         
 199:../button.c   ****                                         D8Led_symbol(14);  /* Mostrar 'E' de Error */
 200:../button.c   ****                                         
 201:../button.c   ****                                         /* Volver a introducir fila */
 202:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 203:../button.c   ****                                         int_count = 0;
 204:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 205:../button.c   ****                                 }
 206:../button.c   ****                         }
 207:../button.c   ****                         break;
 3722              		.loc 1 207 0
 3723 07bc 220000EA 		b	.L7
 3724              	.L28:
 194:../button.c   ****                                         celda_marcar_error(&cuadricula[fila][columna]);
 3725              		.loc 1 194 0
 3726 07c0 94309FE5 		ldr	r3, .L35+4
 3727 07c4 003093E5 		ldr	r3, [r3, #0]
 3728 07c8 0320A0E1 		mov	r2, r3
 3729 07cc 98309FE5 		ldr	r3, .L35+20
 3730 07d0 0030D3E5 		ldrb	r3, [r3, #0]
 3731 07d4 FF3003E2 		and	r3, r3, #255
 3732 07d8 0312A0E1 		mov	r1, r3, asl #4
 3733 07dc 8C309FE5 		ldr	r3, .L35+24
 3734 07e0 0030D3E5 		ldrb	r3, [r3, #0]
 3735 07e4 FF3003E2 		and	r3, r3, #255
 3736 07e8 033081E0 		add	r3, r1, r3
 3737 07ec 8330A0E1 		mov	r3, r3, asl #1
 3738 07f0 033082E0 		add	r3, r2, r3
 3739 07f4 0300A0E1 		mov	r0, r3
 3740 07f8 4FFEFFEB 		bl	celda_marcar_error
 197:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3741              		.loc 1 197 0
 3742 07fc 58309FE5 		ldr	r3, .L35+4
 3743 0800 003093E5 		ldr	r3, [r3, #0]
 3744 0804 0300A0E1 		mov	r0, r3
 3745 0808 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 199:../button.c   ****                                         D8Led_symbol(14);  /* Mostrar 'E' de Error */
 3746              		.loc 1 199 0
 3747 080c 0E00A0E3 		mov	r0, #14
 3748 0810 FEFFFFEB 		bl	D8Led_symbol
 202:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 3749              		.loc 1 202 0
 3750 0814 3C309FE5 		ldr	r3, .L35
 3751 0818 0120A0E3 		mov	r2, #1
 3752 081c 0020C3E5 		strb	r2, [r3, #0]
 203:../button.c   ****                                         int_count = 0;
 3753              		.loc 1 203 0
 3754 0820 3C309FE5 		ldr	r3, .L35+12
 3755 0824 0020A0E3 		mov	r2, #0
 3756 0828 0020C3E5 		strb	r2, [r3, #0]
 204:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 3757              		.loc 1 204 0
 3758 082c 0F00A0E3 		mov	r0, #15
 3759 0830 FEFFFFEB 		bl	D8Led_symbol
 3760              		.loc 1 207 0
 3761 0834 040000EA 		b	.L7
 3762              	.L32:
  78:../button.c   ****                         break;
 3763              		.loc 1 78 0
 3764 0838 0000A0E1 		mov	r0, r0	@ nop
 3765 083c 020000EA 		b	.L7
 3766              	.L33:
  99:../button.c   ****                         break;
 3767              		.loc 1 99 0
 3768 0840 0000A0E1 		mov	r0, r0	@ nop
 3769 0844 000000EA 		b	.L7
 3770              	.L34:
 137:../button.c   ****                         break;
 3771              		.loc 1 137 0
 3772 0848 0000A0E1 		mov	r0, r0	@ nop
 3773              	.L7:
 208:../button.c   ****         }
 209:../button.c   **** }
 3774              		.loc 1 209 0
 3775 084c 0CD04BE2 		sub	sp, fp, #12
 3776 0850 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3777 0854 1EFF2FE1 		bx	lr
 3778              	.L36:
 3779              		.align	2
 3780              	.L35:
 3781 0858 00000000 		.word	estado_juego
 3782 085c 00000000 		.word	cuadricula
 3783 0860 00000000 		.word	celdas_vacias
 3784 0864 01000000 		.word	int_count
 3785 0868 06000000 		.word	pantalla_mostrada
 3786 086c 02000000 		.word	fila
 3787 0870 03000000 		.word	columna
 3788 0874 04000000 		.word	valor
 3789 0878 05000000 		.word	valor_previo
 3790              		.cfi_endproc
 3791              	.LFE7:
 3793              		.align	2
 3794              		.global	Eint4567_ISR
 3796              	Eint4567_ISR:
 3797              	.LFB8:
 210:../button.c   **** 
 211:../button.c   **** /* declaración de función que es rutina de servicio de interrupción
 212:../button.c   ****  * https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
 213:../button.c   **** void Eint4567_ISR(void) __attribute__((interrupt("IRQ")));
 214:../button.c   **** 
 215:../button.c   **** /*--- código de funciones ---*/
 216:../button.c   **** void Eint4567_ISR(void)
 217:../button.c   **** {
 3798              		.loc 1 217 0
 3799              		.cfi_startproc
 3800              		@ Interrupt Service Routine.
 3801              		@ args = 0, pretend = 0, frame = 8
 3802              		@ frame_needed = 1, uses_anonymous_args = 0
 3803 087c 04C02DE5 		str	ip, [sp, #-4]!
 3804 0880 0DC0A0E1 		mov	ip, sp
 3805              	.LCFI14:
 3806              		.cfi_def_cfa_register 12
 3807 0884 0FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 3808 0888 04B04CE2 		sub	fp, ip, #4
 3809              		.cfi_offset 14, -8
 3810              		.cfi_offset 13, -12
 3811              		.cfi_offset 11, -16
 3812              		.cfi_offset 3, -20
 3813              		.cfi_offset 2, -24
 3814              		.cfi_offset 1, -28
 3815              		.cfi_offset 0, -32
 3816              	.LCFI15:
 3817              		.cfi_def_cfa 11, 4
 3818 088c 08D04DE2 		sub	sp, sp, #8
 218:../button.c   ****         /* Identificar la interrupción (hay dos pulsadores) */
 219:../button.c   ****         unsigned int pending = rEXTINTPND & 0xF;
 3819              		.loc 1 219 0
 3820 0890 8C309FE5 		ldr	r3, .L41
 3821 0894 003093E5 		ldr	r3, [r3, #0]
 3822 0898 0F3003E2 		and	r3, r3, #15
 3823 089c 24300BE5 		str	r3, [fp, #-36]
 220:../button.c   ****         uint8_t boton_id = 0;
 3824              		.loc 1 220 0
 3825 08a0 0030A0E3 		mov	r3, #0
 3826 08a4 1D304BE5 		strb	r3, [fp, #-29]
 221:../button.c   **** 
 222:../button.c   ****         if (pending & 0x4)
 3827              		.loc 1 222 0
 3828 08a8 24301BE5 		ldr	r3, [fp, #-36]
 3829 08ac 043003E2 		and	r3, r3, #4
 3830 08b0 000053E3 		cmp	r3, #0
 3831 08b4 0200000A 		beq	.L38
 223:../button.c   ****         {
 224:../button.c   ****                 boton_id = EVENTO_BOTON_IZQUIERDO;
 3832              		.loc 1 224 0
 3833 08b8 0430A0E3 		mov	r3, #4
 3834 08bc 1D304BE5 		strb	r3, [fp, #-29]
 3835 08c0 050000EA 		b	.L39
 3836              	.L38:
 225:../button.c   ****         }
 226:../button.c   ****         else if (pending & 0x8)
 3837              		.loc 1 226 0
 3838 08c4 24301BE5 		ldr	r3, [fp, #-36]
 3839 08c8 083003E2 		and	r3, r3, #8
 3840 08cc 000053E3 		cmp	r3, #0
 3841 08d0 0100000A 		beq	.L39
 227:../button.c   ****         {
 228:../button.c   ****                 boton_id = EVENTO_BOTON_DERECHO;
 3842              		.loc 1 228 0
 3843 08d4 0830A0E3 		mov	r3, #8
 3844 08d8 1D304BE5 		strb	r3, [fp, #-29]
 3845              	.L39:
 229:../button.c   ****         }
 230:../button.c   **** 
 231:../button.c   ****         if (boton_id != 0U)
 3846              		.loc 1 231 0
 3847 08dc 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 3848 08e0 000053E3 		cmp	r3, #0
 3849 08e4 0200000A 		beq	.L40
 232:../button.c   ****         {
 233:../button.c   ****                 /* No registrar la pulsación inicial, solo las confirmadas */
 234:../button.c   **** 
 235:../button.c   ****                 /* Iniciar la máquina de antirrebotes. Si está ocupada, no hacer nada */
 236:../button.c   ****                 timer3_start_antirrebote(boton_id);
 3850              		.loc 1 236 0
 3851 08e8 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 3852 08ec 0300A0E1 		mov	r0, r3
 3853 08f0 FEFFFFEB 		bl	timer3_start_antirrebote
 3854              	.L40:
 237:../button.c   ****         }
 238:../button.c   **** 
 239:../button.c   ****         /* Finalizar ISR */
 240:../button.c   ****         rEXTINTPND = 0xf;                               // borra los bits en EXTINTPND
 3855              		.loc 1 240 0
 3856 08f4 28309FE5 		ldr	r3, .L41
 3857 08f8 0F20A0E3 		mov	r2, #15
 3858 08fc 002083E5 		str	r2, [r3, #0]
 241:../button.c   ****         rI_ISPC   |= BIT_EINT4567;              // borra el bit pendiente en INTPND
 3859              		.loc 1 241 0
 3860 0900 20309FE5 		ldr	r3, .L41+4
 3861 0904 1C209FE5 		ldr	r2, .L41+4
 3862 0908 002092E5 		ldr	r2, [r2, #0]
 3863 090c 022682E3 		orr	r2, r2, #2097152
 3864 0910 002083E5 		str	r2, [r3, #0]
 242:../button.c   **** }
 3865              		.loc 1 242 0
 3866 0914 1CD04BE2 		sub	sp, fp, #28
 3867 0918 0F689DE8 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 3868 091c 04C09DE4 		ldmfd	sp!, {ip}
 3869 0920 04F05EE2 		subs	pc, lr, #4
 3870              	.L42:
 3871              		.align	2
 3872              	.L41:
 3873 0924 5400D201 		.word	30539860
 3874 0928 2400E001 		.word	31457316
 3875              		.cfi_endproc
 3876              	.LFE8:
 3878              		.align	2
 3879              		.global	Eint4567_init
 3881              	Eint4567_init:
 3882              	.LFB9:
 243:../button.c   **** 
 244:../button.c   **** void Eint4567_init(void)
 245:../button.c   **** {
 3883              		.loc 1 245 0
 3884              		.cfi_startproc
 3885              		@ Function supports interworking.
 3886              		@ args = 0, pretend = 0, frame = 0
 3887              		@ frame_needed = 1, uses_anonymous_args = 0
 3888 092c 0DC0A0E1 		mov	ip, sp
 3889              	.LCFI16:
 3890              		.cfi_def_cfa_register 12
 3891 0930 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3892 0934 04B04CE2 		sub	fp, ip, #4
 3893              		.cfi_offset 14, -8
 3894              		.cfi_offset 13, -12
 3895              		.cfi_offset 11, -16
 3896              	.LCFI17:
 3897              		.cfi_def_cfa 11, 4
 246:../button.c   ****         /* Inicializar el temporizador dedicado a la eliminación de rebotes */
 247:../button.c   ****         timer3_init(boton_confirmado);
 3898              		.loc 1 247 0
 3899 0938 AC009FE5 		ldr	r0, .L44
 3900 093c FEFFFFEB 		bl	timer3_init
 248:../button.c   **** 
 249:../button.c   ****         /* Configuracion del controlador de interrupciones. Estos registros están definidos en 44b
 250:../button.c   ****         rI_ISPC    = 0x3ffffff;         // Borra INTPND escribiendo 1s en I_ISPC
 3901              		.loc 1 250 0
 3902 0940 A8309FE5 		ldr	r3, .L44+4
 3903 0944 3F23E0E3 		mvn	r2, #-67108864
 3904 0948 002083E5 		str	r2, [r3, #0]
 251:../button.c   ****         rEXTINTPND = 0xf;               // Borra EXTINTPND escribiendo 1s en el propio registro
 3905              		.loc 1 251 0
 3906 094c A0309FE5 		ldr	r3, .L44+8
 3907 0950 0F20A0E3 		mov	r2, #15
 3908 0954 002083E5 		str	r2, [r3, #0]
 252:../button.c   ****         rINTMOD    = 0x0;               // Configura las lineas como de tipo IRQ
 3909              		.loc 1 252 0
 3910 0958 98309FE5 		ldr	r3, .L44+12
 3911 095c 0020A0E3 		mov	r2, #0
 3912 0960 002083E5 		str	r2, [r3, #0]
 253:../button.c   ****         rINTCON    = 0x1;               // Habilita int. vectorizadas y la linea IRQ (FIQ no)
 3913              		.loc 1 253 0
 3914 0964 1E36A0E3 		mov	r3, #31457280
 3915 0968 0120A0E3 		mov	r2, #1
 3916 096c 002083E5 		str	r2, [r3, #0]
 254:../button.c   ****         rINTMSK    &= ~(BIT_EINT4567);  // habilitamos interrupcion linea eint4567 en vector de mas
 3917              		.loc 1 254 0
 3918 0970 84309FE5 		ldr	r3, .L44+16
 3919 0974 80209FE5 		ldr	r2, .L44+16
 3920 0978 002092E5 		ldr	r2, [r2, #0]
 3921 097c 0226C2E3 		bic	r2, r2, #2097152
 3922 0980 002083E5 		str	r2, [r3, #0]
 255:../button.c   **** 
 256:../button.c   ****         /* Establece la rutina de servicio para Eint4567 */
 257:../button.c   ****         pISR_EINT4567 = (int) Eint4567_ISR;
 3923              		.loc 1 257 0
 3924 0984 74309FE5 		ldr	r3, .L44+20
 3925 0988 74209FE5 		ldr	r2, .L44+24
 3926 098c 002083E5 		str	r2, [r3, #0]
 258:../button.c   **** 
 259:../button.c   ****         /* Configuracion del puerto G */
 260:../button.c   ****         rPCONG  = 0xffff;                       // Establece la funcion de los pines (EINT0-7)
 3927              		.loc 1 260 0
 3928 0990 70309FE5 		ldr	r3, .L44+28
 3929 0994 70209FE5 		ldr	r2, .L44+32
 3930 0998 002083E5 		str	r2, [r3, #0]
 261:../button.c   ****         rPUPG   = 0x0;                  // Habilita el "pull up" del puerto
 3931              		.loc 1 261 0
 3932 099c 6C309FE5 		ldr	r3, .L44+36
 3933 09a0 0020A0E3 		mov	r2, #0
 3934 09a4 002083E5 		str	r2, [r3, #0]
 262:../button.c   ****         rEXTINT = rEXTINT | 0x22222222;   // Configura las lineas de int. como de flanco de bajada
 3935              		.loc 1 262 0
 3936 09a8 64209FE5 		ldr	r2, .L44+40
 3937 09ac 60309FE5 		ldr	r3, .L44+40
 3938 09b0 001093E5 		ldr	r1, [r3, #0]
 3939 09b4 5C309FE5 		ldr	r3, .L44+44
 3940 09b8 033081E1 		orr	r3, r1, r3
 3941 09bc 003082E5 		str	r3, [r2, #0]
 263:../button.c   **** 
 264:../button.c   ****         /* Por precaucion, se vuelven a borrar los bits de INTPND y EXTINTPND */
 265:../button.c   ****         rEXTINTPND = 0xf;                               // borra los bits en EXTINTPND
 3942              		.loc 1 265 0
 3943 09c0 2C309FE5 		ldr	r3, .L44+8
 3944 09c4 0F20A0E3 		mov	r2, #15
 3945 09c8 002083E5 		str	r2, [r3, #0]
 266:../button.c   ****         rI_ISPC   |= BIT_EINT4567;              // borra el bit pendiente en INTPND
 3946              		.loc 1 266 0
 3947 09cc 1C309FE5 		ldr	r3, .L44+4
 3948 09d0 18209FE5 		ldr	r2, .L44+4
 3949 09d4 002092E5 		ldr	r2, [r2, #0]
 3950 09d8 022682E3 		orr	r2, r2, #2097152
 3951 09dc 002083E5 		str	r2, [r3, #0]
 267:../button.c   **** }
 3952              		.loc 1 267 0
 3953 09e0 0CD04BE2 		sub	sp, fp, #12
 3954 09e4 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3955 09e8 1EFF2FE1 		bx	lr
 3956              	.L45:
 3957              		.align	2
 3958              	.L44:
 3959 09ec 00000000 		.word	boton_confirmado
 3960 09f0 2400E001 		.word	31457316
 3961 09f4 5400D201 		.word	30539860
 3962 09f8 0800E001 		.word	31457288
 3963 09fc 0C00E001 		.word	31457292
 3964 0a00 74FF7F0C 		.word	209715060
 3965 0a04 00000000 		.word	Eint4567_ISR
 3966 0a08 4000D201 		.word	30539840
 3967 0a0c FFFF0000 		.word	65535
 3968 0a10 4800D201 		.word	30539848
 3969 0a14 5000D201 		.word	30539856
 3970 0a18 22222222 		.word	572662306
 3971              		.cfi_endproc
 3972              	.LFE9:
 3974              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 button.c
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:2979   .text:00000000 $a
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:2981   .text:00000000 celda_poner_valor
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3032   .text:00000078 celda_leer_valor
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3067   .text:000000b0 celda_es_candidato
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3108   .text:00000100 celda_es_pista
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3144   .text:0000013c celda_marcar_error
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3180   .text:00000178 celda_limpiar_error
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3215   .bss:00000000 estado_juego
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3216   .bss:00000000 $d
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3217   .bss:00000001 int_count
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3219   .bss:00000002 fila
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3221   .bss:00000003 columna
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3223   .bss:00000004 valor
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3225   .bss:00000005 valor_previo
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3227   .bss:00000006 pantalla_mostrada
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3232   .text:000001b4 boton_confirmado
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3271   .text:0000020c $d
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3279   .text:00000224 $a
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3781   .text:00000858 $d
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3793   .text:0000087c $a
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3796   .text:0000087c Eint4567_ISR
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3873   .text:00000924 $d
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3878   .text:0000092c $a
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3881   .text:0000092c Eint4567_init
C:\Users\jaime\AppData\Local\Temp\ccyIDJdd.s:3959   .text:000009ec $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
timer2_count
cola_depuracion
candidatos_actualizar_all
Sudoku_Dibujar_Tablero
Sudoku_Actualizar_Tablero_Completo
D8Led_symbol
candidatos_propagar_arm
cuadricula
celdas_vacias
timer3_start_antirrebote
timer3_init
