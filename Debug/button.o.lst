   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"button.c"
  21              	.Ltext0:
  22              		.file 1 "../button.c"
 2979              		.align	2
 2981              	celda_poner_valor:
 2982              	.LFB1:
   1:../celda.h    **** 	/* guarda para evitar inclusiones mÃºltiples (include guard) */
   2:../celda.h    **** 	#ifndef CELDA_H
   3:../celda.h    **** 	#define CELDA_H
   4:../celda.h    **** 	
   5:../celda.h    **** 	#include <inttypes.h>
   6:../celda.h    **** 	
   7:../celda.h    **** 	/* Cada celda se codifica en 16 bits
   8:../celda.h    **** 	 * bits [15,7]: los 9 bits mÃ¡s significativos representan el vector de candidatos,
   9:../celda.h    **** 	 * si el bit 7 + valor - 1 estÃ¡ a 0, valor es candidato, 1 en caso contrario
  10:../celda.h    **** 	 * bit 6: no empleado
  11:../celda.h    **** 	 * bit 5: error
  12:../celda.h    **** 	 * bit 4: pista
  13:../celda.h    **** 	 * bits [3,0]: valor de la celda
  14:../celda.h    **** 	 */
  15:../celda.h    **** 	
  16:../celda.h    **** enum { BIT_CANDIDATOS = 7, BIT_NO_USADO = 6, BIT_ERROR = 5, BIT_PISTA = 4 };
  17:../celda.h    **** 	
  18:../celda.h    **** 	typedef uint16_t CELDA;
  19:../celda.h    **** 	
  20:../celda.h    **** 	/* *****************************************************************************
  21:../celda.h    **** 	 * elimina el candidato del valor almacenado en la celda indicada */
  22:../celda.h    **** 	__inline static void
  23:../celda.h    **** 	celda_eliminar_candidato(CELDA *celdaptr, uint8_t valor)
  24:../celda.h    **** 	{
  25:../celda.h    **** 		*celdaptr = *celdaptr | (0x0001 << (BIT_CANDIDATOS + valor - 1));
  26:../celda.h    **** 	}
  27:../celda.h    **** 	
  28:../celda.h    **** 	/* *****************************************************************************
  29:../celda.h    **** 	 * modifica el valor almacenado en la celda indicada */
  30:../celda.h    **** 	__inline static void
  31:../celda.h    **** 	celda_poner_valor(CELDA *celdaptr, uint8_t val)
  32:../celda.h    **** 	{
 2983              		.loc 17 32 0
 2984              		.cfi_startproc
 2985              		@ Function supports interworking.
 2986              		@ args = 0, pretend = 0, frame = 8
 2987              		@ frame_needed = 1, uses_anonymous_args = 0
 2988 0000 0DC0A0E1 		mov	ip, sp
 2989              	.LCFI0:
 2990              		.cfi_def_cfa_register 12
 2991 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2992 0008 04B04CE2 		sub	fp, ip, #4
 2993              		.cfi_offset 14, -8
 2994              		.cfi_offset 13, -12
 2995              		.cfi_offset 11, -16
 2996              	.LCFI1:
 2997              		.cfi_def_cfa 11, 4
 2998 000c 08D04DE2 		sub	sp, sp, #8
 2999 0010 10000BE5 		str	r0, [fp, #-16]
 3000 0014 0130A0E1 		mov	r3, r1
 3001 0018 11304BE5 		strb	r3, [fp, #-17]
  33:../celda.h    **** 		*celdaptr = (*celdaptr & 0xFFF0) | (val & 0x000F);
 3002              		.loc 17 33 0
 3003 001c 10301BE5 		ldr	r3, [fp, #-16]
 3004 0020 B030D3E1 		ldrh	r3, [r3, #0]
 3005 0024 0338A0E1 		mov	r3, r3, asl #16
 3006 0028 2338A0E1 		mov	r3, r3, lsr #16
 3007 002c 0F30C3E3 		bic	r3, r3, #15
 3008 0030 0338A0E1 		mov	r3, r3, asl #16
 3009 0034 2328A0E1 		mov	r2, r3, lsr #16
 3010 0038 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3011 003c 0338A0E1 		mov	r3, r3, asl #16
 3012 0040 2338A0E1 		mov	r3, r3, lsr #16
 3013 0044 0F3003E2 		and	r3, r3, #15
 3014 0048 0338A0E1 		mov	r3, r3, asl #16
 3015 004c 2338A0E1 		mov	r3, r3, lsr #16
 3016 0050 033082E1 		orr	r3, r2, r3
 3017 0054 0338A0E1 		mov	r3, r3, asl #16
 3018 0058 2338A0E1 		mov	r3, r3, lsr #16
 3019 005c 0338A0E1 		mov	r3, r3, asl #16
 3020 0060 2328A0E1 		mov	r2, r3, lsr #16
 3021 0064 10301BE5 		ldr	r3, [fp, #-16]
 3022 0068 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  34:../celda.h    **** 	}
 3023              		.loc 17 34 0
 3024 006c 0CD04BE2 		sub	sp, fp, #12
 3025 0070 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3026 0074 1EFF2FE1 		bx	lr
 3027              		.cfi_endproc
 3028              	.LFE1:
 3030              		.align	2
 3032              	celda_leer_valor:
 3033              	.LFB2:
  35:../celda.h    **** 	
  36:../celda.h    **** 	/* *****************************************************************************
  37:../celda.h    **** 	 * extrae el valor almacenado en los 16 bits de una celda */
  38:../celda.h    ****         __inline static uint8_t
  39:../celda.h    ****         celda_leer_valor(CELDA celda)
  40:../celda.h    ****         {
 3034              		.loc 17 40 0
 3035              		.cfi_startproc
 3036              		@ Function supports interworking.
 3037              		@ args = 0, pretend = 0, frame = 8
 3038              		@ frame_needed = 1, uses_anonymous_args = 0
 3039 0078 0DC0A0E1 		mov	ip, sp
 3040              	.LCFI2:
 3041              		.cfi_def_cfa_register 12
 3042 007c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3043 0080 04B04CE2 		sub	fp, ip, #4
 3044              		.cfi_offset 14, -8
 3045              		.cfi_offset 13, -12
 3046              		.cfi_offset 11, -16
 3047              	.LCFI3:
 3048              		.cfi_def_cfa 11, 4
 3049 0084 08D04DE2 		sub	sp, sp, #8
 3050 0088 0030A0E1 		mov	r3, r0
 3051 008c BE304BE1 		strh	r3, [fp, #-14]	@ movhi
  41:../celda.h    ****                 return (celda & 0x000F);
 3052              		.loc 17 41 0
 3053 0090 BE305BE1 		ldrh	r3, [fp, #-14]	@ movhi
 3054 0094 FF3003E2 		and	r3, r3, #255
 3055 0098 0F3003E2 		and	r3, r3, #15
 3056 009c FF3003E2 		and	r3, r3, #255
  42:../celda.h    ****         }
 3057              		.loc 17 42 0
 3058 00a0 0300A0E1 		mov	r0, r3
 3059 00a4 0CD04BE2 		sub	sp, fp, #12
 3060 00a8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3061 00ac 1EFF2FE1 		bx	lr
 3062              		.cfi_endproc
 3063              	.LFE2:
 3065              		.align	2
 3067              	celda_es_candidato:
 3068              	.LFB3:
  43:../celda.h    **** 
  44:../celda.h    ****         /* *****************************************************************************
  45:../celda.h    ****          * comprueba si el valor es candidato en la celda indicada */
  46:../celda.h    ****         __inline static int
  47:../celda.h    ****         celda_es_candidato(CELDA celda, uint8_t valor)
  48:../celda.h    ****         {
 3069              		.loc 17 48 0
 3070              		.cfi_startproc
 3071              		@ Function supports interworking.
 3072              		@ args = 0, pretend = 0, frame = 8
 3073              		@ frame_needed = 1, uses_anonymous_args = 0
 3074 00b0 0DC0A0E1 		mov	ip, sp
 3075              	.LCFI4:
 3076              		.cfi_def_cfa_register 12
 3077 00b4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3078 00b8 04B04CE2 		sub	fp, ip, #4
 3079              		.cfi_offset 14, -8
 3080              		.cfi_offset 13, -12
 3081              		.cfi_offset 11, -16
 3082              	.LCFI5:
 3083              		.cfi_def_cfa 11, 4
 3084 00bc 08D04DE2 		sub	sp, sp, #8
 3085 00c0 0020A0E1 		mov	r2, r0
 3086 00c4 0130A0E1 		mov	r3, r1
 3087 00c8 BE204BE1 		strh	r2, [fp, #-14]	@ movhi
 3088 00cc 0F304BE5 		strb	r3, [fp, #-15]
  49:../celda.h    ****                 return (celda & (0x0001 << (BIT_CANDIDATOS + valor - 1))) == 0;
 3089              		.loc 17 49 0
 3090 00d0 BE205BE1 		ldrh	r2, [fp, #-14]
 3091 00d4 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3092 00d8 063083E2 		add	r3, r3, #6
 3093 00dc 5233A0E1 		mov	r3, r2, asr r3
 3094 00e0 013003E2 		and	r3, r3, #1
 3095 00e4 000053E3 		cmp	r3, #0
 3096 00e8 0030A013 		movne	r3, #0
 3097 00ec 0130A003 		moveq	r3, #1
  50:../celda.h    ****         }
 3098              		.loc 17 50 0
 3099 00f0 0300A0E1 		mov	r0, r3
 3100 00f4 0CD04BE2 		sub	sp, fp, #12
 3101 00f8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3102 00fc 1EFF2FE1 		bx	lr
 3103              		.cfi_endproc
 3104              	.LFE3:
 3106              		.align	2
 3108              	celda_es_pista:
 3109              	.LFB4:
  51:../celda.h    **** 
  52:../celda.h    ****         /* *****************************************************************************
  53:../celda.h    ****          * comprueba si la celda es una pista */
  54:../celda.h    ****         __inline static int
  55:../celda.h    ****         celda_es_pista(CELDA celda)
  56:../celda.h    ****         {
 3110              		.loc 17 56 0
 3111              		.cfi_startproc
 3112              		@ Function supports interworking.
 3113              		@ args = 0, pretend = 0, frame = 8
 3114              		@ frame_needed = 1, uses_anonymous_args = 0
 3115 0100 0DC0A0E1 		mov	ip, sp
 3116              	.LCFI6:
 3117              		.cfi_def_cfa_register 12
 3118 0104 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3119 0108 04B04CE2 		sub	fp, ip, #4
 3120              		.cfi_offset 14, -8
 3121              		.cfi_offset 13, -12
 3122              		.cfi_offset 11, -16
 3123              	.LCFI7:
 3124              		.cfi_def_cfa 11, 4
 3125 010c 08D04DE2 		sub	sp, sp, #8
 3126 0110 0030A0E1 		mov	r3, r0
 3127 0114 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
  57:../celda.h    ****                 return (celda & (1 << BIT_PISTA)) != 0;
 3128              		.loc 17 57 0
 3129 0118 BE305BE1 		ldrh	r3, [fp, #-14]
 3130 011c 103003E2 		and	r3, r3, #16
 3131 0120 000053E3 		cmp	r3, #0
 3132 0124 0030A003 		moveq	r3, #0
 3133 0128 0130A013 		movne	r3, #1
  58:../celda.h    ****         }
 3134              		.loc 17 58 0
 3135 012c 0300A0E1 		mov	r0, r3
 3136 0130 0CD04BE2 		sub	sp, fp, #12
 3137 0134 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3138 0138 1EFF2FE1 		bx	lr
 3139              		.cfi_endproc
 3140              	.LFE4:
 3142              		.align	2
 3144              	celda_marcar_error:
 3145              	.LFB5:
  59:../celda.h    **** 
  60:../celda.h    ****         /* *****************************************************************************
  61:../celda.h    ****          * marca o limpia el bit de error de la celda */
  62:../celda.h    ****         __inline static void
  63:../celda.h    ****         celda_marcar_error(CELDA *celdaptr)
  64:../celda.h    ****         {
 3146              		.loc 17 64 0
 3147              		.cfi_startproc
 3148              		@ Function supports interworking.
 3149              		@ args = 0, pretend = 0, frame = 8
 3150              		@ frame_needed = 1, uses_anonymous_args = 0
 3151 013c 0DC0A0E1 		mov	ip, sp
 3152              	.LCFI8:
 3153              		.cfi_def_cfa_register 12
 3154 0140 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3155 0144 04B04CE2 		sub	fp, ip, #4
 3156              		.cfi_offset 14, -8
 3157              		.cfi_offset 13, -12
 3158              		.cfi_offset 11, -16
 3159              	.LCFI9:
 3160              		.cfi_def_cfa 11, 4
 3161 0148 08D04DE2 		sub	sp, sp, #8
 3162 014c 10000BE5 		str	r0, [fp, #-16]
  65:../celda.h    ****                 *celdaptr |= (1 << BIT_ERROR);
 3163              		.loc 17 65 0
 3164 0150 10301BE5 		ldr	r3, [fp, #-16]
 3165 0154 B030D3E1 		ldrh	r3, [r3, #0]
 3166 0158 203083E3 		orr	r3, r3, #32
 3167 015c 0338A0E1 		mov	r3, r3, asl #16
 3168 0160 2328A0E1 		mov	r2, r3, lsr #16
 3169 0164 10301BE5 		ldr	r3, [fp, #-16]
 3170 0168 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  66:../celda.h    ****         }
 3171              		.loc 17 66 0
 3172 016c 0CD04BE2 		sub	sp, fp, #12
 3173 0170 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3174 0174 1EFF2FE1 		bx	lr
 3175              		.cfi_endproc
 3176              	.LFE5:
 3178              		.align	2
 3180              	celda_limpiar_error:
 3181              	.LFB6:
  67:../celda.h    **** 
  68:../celda.h    ****         __inline static void
  69:../celda.h    ****         celda_limpiar_error(CELDA *celdaptr)
  70:../celda.h    ****         {
 3182              		.loc 17 70 0
 3183              		.cfi_startproc
 3184              		@ Function supports interworking.
 3185              		@ args = 0, pretend = 0, frame = 8
 3186              		@ frame_needed = 1, uses_anonymous_args = 0
 3187 0178 0DC0A0E1 		mov	ip, sp
 3188              	.LCFI10:
 3189              		.cfi_def_cfa_register 12
 3190 017c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3191 0180 04B04CE2 		sub	fp, ip, #4
 3192              		.cfi_offset 14, -8
 3193              		.cfi_offset 13, -12
 3194              		.cfi_offset 11, -16
 3195              	.LCFI11:
 3196              		.cfi_def_cfa 11, 4
 3197 0184 08D04DE2 		sub	sp, sp, #8
 3198 0188 10000BE5 		str	r0, [fp, #-16]
  71:../celda.h    ****                 *celdaptr &= ~(1 << BIT_ERROR);
 3199              		.loc 17 71 0
 3200 018c 10301BE5 		ldr	r3, [fp, #-16]
 3201 0190 B030D3E1 		ldrh	r3, [r3, #0]
 3202 0194 2030C3E3 		bic	r3, r3, #32
 3203 0198 0338A0E1 		mov	r3, r3, asl #16
 3204 019c 2328A0E1 		mov	r2, r3, lsr #16
 3205 01a0 10301BE5 		ldr	r3, [fp, #-16]
 3206 01a4 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  72:../celda.h    ****         }
 3207              		.loc 17 72 0
 3208 01a8 0CD04BE2 		sub	sp, fp, #12
 3209 01ac 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3210 01b0 1EFF2FE1 		bx	lr
 3211              		.cfi_endproc
 3212              	.LFE6:
 3214              		.bss
 3215              	estado_juego:
 3216 0000 00       		.space	1
 3217              	int_count:
 3218 0001 00       		.space	1
 3219              	fila:
 3220 0002 00       		.space	1
 3221              	columna:
 3222 0003 00       		.space	1
 3223              	valor:
 3224 0004 00       		.space	1
 3225              	valor_previo:
 3226 0005 00       		.space	1
 3227              	pantalla_mostrada:
 3228 0006 00       		.space	1
 3229 0007 00       		.align	2
 3230              	tiempo_inicio:
 3231 0008 00000000 		.space	4
 3232              		.align	2
 3233              	tiempo_final:
 3234 000c 00000000 		.space	4
 3235              		.text
 3236              		.align	2
 3238              	marcar_celdas_en_conflicto:
 3239              	.LFB7:
   1:../button.c   **** /*********************************************************************************************
   2:../button.c   **** * Fichero:      button.c
   3:../button.c   **** * Autor:
   4:../button.c   **** * Descrip:      Funciones de manejo de los pulsadores (EINT6-7)
   5:../button.c   **** * Version:
   6:../button.c   **** *********************************************************************************************/
   7:../button.c   **** 
   8:../button.c   **** /*--- ficheros de cabecera ---*/
   9:../button.c   **** #include "button.h"
  10:../button.c   **** #include "8led.h"
  11:../button.c   **** #include "cola.h"
  12:../button.c   **** #include "eventos.h"
  13:../button.c   **** #include "timer2.h"
  14:../button.c   **** #include "timer3.h"
  15:../button.c   **** #include "44blib.h"
  16:../button.c   **** #include "44b.h"
  17:../button.c   **** #include "def.h"
  18:../button.c   **** #include "sudoku_2025.h"
  19:../button.c   **** #include "lcd.h"
  20:../button.c   **** 
  21:../button.c   **** /*--- Variables del juego Sudoku ---*/
  22:../button.c   **** static volatile EstadoSudoku estado_juego = ESPERANDO_INICIO;
  23:../button.c   **** static volatile uint8_t int_count = 0;
  24:../button.c   **** static volatile uint8_t fila = 0;
  25:../button.c   **** static volatile uint8_t columna = 0;
  26:../button.c   **** static volatile uint8_t valor = 0;
  27:../button.c   **** static volatile uint8_t valor_previo = 0;  /* Para detectar modificación de valor */
  28:../button.c   **** static volatile uint8_t pantalla_mostrada = 0;  /* Flag para mostrar pantalla inicial solo una vez 
  29:../button.c   **** static volatile uint32_t tiempo_inicio = 0;  /* Tiempo de inicio de la partida actual */
  30:../button.c   **** static volatile uint32_t tiempo_final = 0;  /* Tiempo final al terminar la partida */
  31:../button.c   **** 
  32:../button.c   **** /* Declaración externa de la cuadrícula del juego */
  33:../button.c   **** extern CELDA (*cuadricula)[NUM_COLUMNAS];
  34:../button.c   **** extern int celdas_vacias;
  35:../button.c   **** 
  36:../button.c   **** /* Función auxiliar para marcar todas las celdas en conflicto con un valor */
  37:../button.c   **** static void marcar_celdas_en_conflicto(uint8_t fila_error, uint8_t col_error, uint8_t valor_error)
  38:../button.c   **** {
 3240              		.loc 1 38 0
 3241              		.cfi_startproc
 3242              		@ Function supports interworking.
 3243              		@ args = 0, pretend = 0, frame = 16
 3244              		@ frame_needed = 1, uses_anonymous_args = 0
 3245 01b4 0DC0A0E1 		mov	ip, sp
 3246              	.LCFI12:
 3247              		.cfi_def_cfa_register 12
 3248 01b8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3249 01bc 04B04CE2 		sub	fp, ip, #4
 3250              		.cfi_offset 14, -8
 3251              		.cfi_offset 13, -12
 3252              		.cfi_offset 11, -16
 3253              	.LCFI13:
 3254              		.cfi_def_cfa 11, 4
 3255 01c0 10D04DE2 		sub	sp, sp, #16
 3256 01c4 0230A0E1 		mov	r3, r2
 3257 01c8 0020A0E1 		mov	r2, r0
 3258 01cc 15204BE5 		strb	r2, [fp, #-21]
 3259 01d0 0120A0E1 		mov	r2, r1
 3260 01d4 16204BE5 		strb	r2, [fp, #-22]
 3261 01d8 17304BE5 		strb	r3, [fp, #-23]
  39:../button.c   **** 	uint8_t i, f, c;
  40:../button.c   **** 	uint8_t region_fila_inicio, region_col_inicio;
  41:../button.c   **** 	
  42:../button.c   **** 	/* Primero limpiar todos los errores previos */
  43:../button.c   **** 	for (f = 0; f < NUM_FILAS; f++)
 3262              		.loc 1 43 0
 3263 01dc 0030A0E3 		mov	r3, #0
 3264 01e0 0E304BE5 		strb	r3, [fp, #-14]
 3265 01e4 160000EA 		b	.L8
 3266              	.L11:
  44:../button.c   **** 	{
  45:../button.c   **** 		for (c = 0; c < NUM_COLUMNAS; c++)
 3267              		.loc 1 45 0
 3268 01e8 0030A0E3 		mov	r3, #0
 3269 01ec 0F304BE5 		strb	r3, [fp, #-15]
 3270 01f0 0D0000EA 		b	.L9
 3271              	.L10:
  46:../button.c   **** 		{
  47:../button.c   **** 			celda_limpiar_error(&cuadricula[f][c]);
 3272              		.loc 1 47 0 discriminator 2
 3273 01f4 EC329FE5 		ldr	r3, .L24
 3274 01f8 003093E5 		ldr	r3, [r3, #0]
 3275 01fc 0320A0E1 		mov	r2, r3
 3276 0200 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3277 0204 0312A0E1 		mov	r1, r3, asl #4
 3278 0208 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3279 020c 033081E0 		add	r3, r1, r3
 3280 0210 8330A0E1 		mov	r3, r3, asl #1
 3281 0214 033082E0 		add	r3, r2, r3
 3282 0218 0300A0E1 		mov	r0, r3
 3283 021c D5FFFFEB 		bl	celda_limpiar_error
  45:../button.c   **** 		for (c = 0; c < NUM_COLUMNAS; c++)
 3284              		.loc 1 45 0 discriminator 2
 3285 0220 0F305BE5 		ldrb	r3, [fp, #-15]
 3286 0224 013083E2 		add	r3, r3, #1
 3287 0228 0F304BE5 		strb	r3, [fp, #-15]
 3288              	.L9:
  45:../button.c   **** 		for (c = 0; c < NUM_COLUMNAS; c++)
 3289              		.loc 1 45 0 is_stmt 0 discriminator 1
 3290 022c 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3291 0230 0F0053E3 		cmp	r3, #15
 3292 0234 EEFFFF9A 		bls	.L10
  43:../button.c   **** 	for (f = 0; f < NUM_FILAS; f++)
 3293              		.loc 1 43 0 is_stmt 1
 3294 0238 0E305BE5 		ldrb	r3, [fp, #-14]
 3295 023c 013083E2 		add	r3, r3, #1
 3296 0240 0E304BE5 		strb	r3, [fp, #-14]
 3297              	.L8:
  43:../button.c   **** 	for (f = 0; f < NUM_FILAS; f++)
 3298              		.loc 1 43 0 is_stmt 0 discriminator 1
 3299 0244 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3300 0248 080053E3 		cmp	r3, #8
 3301 024c E5FFFF9A 		bls	.L11
  48:../button.c   **** 		}
  49:../button.c   **** 	}
  50:../button.c   **** 	
  51:../button.c   **** 	/* Marcar la celda donde intentamos poner el valor */
  52:../button.c   **** 	celda_marcar_error(&cuadricula[fila_error][col_error]);
 3302              		.loc 1 52 0 is_stmt 1
 3303 0250 90329FE5 		ldr	r3, .L24
 3304 0254 003093E5 		ldr	r3, [r3, #0]
 3305 0258 0320A0E1 		mov	r2, r3
 3306 025c 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3307 0260 0312A0E1 		mov	r1, r3, asl #4
 3308 0264 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 3309 0268 033081E0 		add	r3, r1, r3
 3310 026c 8330A0E1 		mov	r3, r3, asl #1
 3311 0270 033082E0 		add	r3, r2, r3
 3312 0274 0300A0E1 		mov	r0, r3
 3313 0278 AFFFFFEB 		bl	celda_marcar_error
  53:../button.c   **** 	
  54:../button.c   **** 	/* Buscar y marcar todas las celdas con el mismo valor en la misma fila */
  55:../button.c   **** 	for (i = 0; i < NUM_COLUMNAS; i++)
 3314              		.loc 1 55 0
 3315 027c 0030A0E3 		mov	r3, #0
 3316 0280 0D304BE5 		strb	r3, [fp, #-13]
 3317 0284 200000EA 		b	.L12
 3318              	.L14:
  56:../button.c   **** 	{
  57:../button.c   **** 		if (i != col_error && celda_leer_valor(cuadricula[fila_error][i]) == valor_error)
 3319              		.loc 1 57 0
 3320 0288 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 3321 028c 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 3322 0290 030052E1 		cmp	r2, r3
 3323 0294 1900000A 		beq	.L13
 3324              		.loc 1 57 0 is_stmt 0 discriminator 1
 3325 0298 48329FE5 		ldr	r3, .L24
 3326 029c 002093E5 		ldr	r2, [r3, #0]
 3327 02a0 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3328 02a4 8332A0E1 		mov	r3, r3, asl #5
 3329 02a8 032082E0 		add	r2, r2, r3
 3330 02ac 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3331 02b0 8330A0E1 		mov	r3, r3, asl #1
 3332 02b4 033082E0 		add	r3, r2, r3
 3333 02b8 B030D3E1 		ldrh	r3, [r3, #0]
 3334 02bc 0300A0E1 		mov	r0, r3
 3335 02c0 6CFFFFEB 		bl	celda_leer_valor
 3336 02c4 0030A0E1 		mov	r3, r0
 3337 02c8 17205BE5 		ldrb	r2, [fp, #-23]	@ zero_extendqisi2
 3338 02cc 030052E1 		cmp	r2, r3
 3339 02d0 0A00001A 		bne	.L13
  58:../button.c   **** 		{
  59:../button.c   **** 			celda_marcar_error(&cuadricula[fila_error][i]);
 3340              		.loc 1 59 0 is_stmt 1
 3341 02d4 0C329FE5 		ldr	r3, .L24
 3342 02d8 003093E5 		ldr	r3, [r3, #0]
 3343 02dc 0320A0E1 		mov	r2, r3
 3344 02e0 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3345 02e4 0312A0E1 		mov	r1, r3, asl #4
 3346 02e8 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3347 02ec 033081E0 		add	r3, r1, r3
 3348 02f0 8330A0E1 		mov	r3, r3, asl #1
 3349 02f4 033082E0 		add	r3, r2, r3
 3350 02f8 0300A0E1 		mov	r0, r3
 3351 02fc 8EFFFFEB 		bl	celda_marcar_error
 3352              	.L13:
  55:../button.c   **** 	for (i = 0; i < NUM_COLUMNAS; i++)
 3353              		.loc 1 55 0
 3354 0300 0D305BE5 		ldrb	r3, [fp, #-13]
 3355 0304 013083E2 		add	r3, r3, #1
 3356 0308 0D304BE5 		strb	r3, [fp, #-13]
 3357              	.L12:
  55:../button.c   **** 	for (i = 0; i < NUM_COLUMNAS; i++)
 3358              		.loc 1 55 0 is_stmt 0 discriminator 1
 3359 030c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3360 0310 0F0053E3 		cmp	r3, #15
 3361 0314 DBFFFF9A 		bls	.L14
  60:../button.c   **** 		}
  61:../button.c   **** 	}
  62:../button.c   **** 	
  63:../button.c   **** 	/* Buscar y marcar todas las celdas con el mismo valor en la misma columna */
  64:../button.c   **** 	for (i = 0; i < NUM_FILAS; i++)
 3362              		.loc 1 64 0 is_stmt 1
 3363 0318 0030A0E3 		mov	r3, #0
 3364 031c 0D304BE5 		strb	r3, [fp, #-13]
 3365 0320 200000EA 		b	.L15
 3366              	.L17:
  65:../button.c   **** 	{
  66:../button.c   **** 		if (i != fila_error && celda_leer_valor(cuadricula[i][col_error]) == valor_error)
 3367              		.loc 1 66 0
 3368 0324 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 3369 0328 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3370 032c 030052E1 		cmp	r2, r3
 3371 0330 1900000A 		beq	.L16
 3372              		.loc 1 66 0 is_stmt 0 discriminator 1
 3373 0334 AC319FE5 		ldr	r3, .L24
 3374 0338 002093E5 		ldr	r2, [r3, #0]
 3375 033c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3376 0340 8332A0E1 		mov	r3, r3, asl #5
 3377 0344 032082E0 		add	r2, r2, r3
 3378 0348 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 3379 034c 8330A0E1 		mov	r3, r3, asl #1
 3380 0350 033082E0 		add	r3, r2, r3
 3381 0354 B030D3E1 		ldrh	r3, [r3, #0]
 3382 0358 0300A0E1 		mov	r0, r3
 3383 035c 45FFFFEB 		bl	celda_leer_valor
 3384 0360 0030A0E1 		mov	r3, r0
 3385 0364 17205BE5 		ldrb	r2, [fp, #-23]	@ zero_extendqisi2
 3386 0368 030052E1 		cmp	r2, r3
 3387 036c 0A00001A 		bne	.L16
  67:../button.c   **** 		{
  68:../button.c   **** 			celda_marcar_error(&cuadricula[i][col_error]);
 3388              		.loc 1 68 0 is_stmt 1
 3389 0370 70319FE5 		ldr	r3, .L24
 3390 0374 003093E5 		ldr	r3, [r3, #0]
 3391 0378 0320A0E1 		mov	r2, r3
 3392 037c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3393 0380 0312A0E1 		mov	r1, r3, asl #4
 3394 0384 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 3395 0388 033081E0 		add	r3, r1, r3
 3396 038c 8330A0E1 		mov	r3, r3, asl #1
 3397 0390 033082E0 		add	r3, r2, r3
 3398 0394 0300A0E1 		mov	r0, r3
 3399 0398 67FFFFEB 		bl	celda_marcar_error
 3400              	.L16:
  64:../button.c   **** 	for (i = 0; i < NUM_FILAS; i++)
 3401              		.loc 1 64 0
 3402 039c 0D305BE5 		ldrb	r3, [fp, #-13]
 3403 03a0 013083E2 		add	r3, r3, #1
 3404 03a4 0D304BE5 		strb	r3, [fp, #-13]
 3405              	.L15:
  64:../button.c   **** 	for (i = 0; i < NUM_FILAS; i++)
 3406              		.loc 1 64 0 is_stmt 0 discriminator 1
 3407 03a8 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3408 03ac 080053E3 		cmp	r3, #8
 3409 03b0 DBFFFF9A 		bls	.L17
  69:../button.c   **** 		}
  70:../button.c   **** 	}
  71:../button.c   **** 	
  72:../button.c   **** 	/* Buscar y marcar todas las celdas con el mismo valor en la misma región 3x3 */
  73:../button.c   **** 	region_fila_inicio = (fila_error / 3) * 3;
 3410              		.loc 1 73 0 is_stmt 1
 3411 03b4 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 3412 03b8 2C319FE5 		ldr	r3, .L24+4
 3413 03bc 921383E0 		umull	r1, r3, r2, r3
 3414 03c0 A330A0E1 		mov	r3, r3, lsr #1
 3415 03c4 FF3003E2 		and	r3, r3, #255
 3416 03c8 0320A0E1 		mov	r2, r3
 3417 03cc 8220A0E1 		mov	r2, r2, asl #1
 3418 03d0 033082E0 		add	r3, r2, r3
 3419 03d4 10304BE5 		strb	r3, [fp, #-16]
  74:../button.c   **** 	region_col_inicio = (col_error / 3) * 3;
 3420              		.loc 1 74 0
 3421 03d8 16205BE5 		ldrb	r2, [fp, #-22]	@ zero_extendqisi2
 3422 03dc 08319FE5 		ldr	r3, .L24+4
 3423 03e0 921383E0 		umull	r1, r3, r2, r3
 3424 03e4 A330A0E1 		mov	r3, r3, lsr #1
 3425 03e8 FF3003E2 		and	r3, r3, #255
 3426 03ec 0320A0E1 		mov	r2, r3
 3427 03f0 8220A0E1 		mov	r2, r2, asl #1
 3428 03f4 033082E0 		add	r3, r2, r3
 3429 03f8 11304BE5 		strb	r3, [fp, #-17]
  75:../button.c   **** 	
  76:../button.c   **** 	for (f = region_fila_inicio; f < region_fila_inicio + 3; f++)
 3430              		.loc 1 76 0
 3431 03fc 10305BE5 		ldrb	r3, [fp, #-16]
 3432 0400 0E304BE5 		strb	r3, [fp, #-14]
 3433 0404 2F0000EA 		b	.L18
 3434              	.L23:
  77:../button.c   **** 	{
  78:../button.c   **** 		for (c = region_col_inicio; c < region_col_inicio + 3; c++)
 3435              		.loc 1 78 0
 3436 0408 11305BE5 		ldrb	r3, [fp, #-17]
 3437 040c 0F304BE5 		strb	r3, [fp, #-15]
 3438 0410 240000EA 		b	.L19
 3439              	.L22:
  79:../button.c   **** 		{
  80:../button.c   **** 			if ((f != fila_error || c != col_error) && celda_leer_valor(cuadricula[f][c]) == valor_error)
 3440              		.loc 1 80 0
 3441 0414 0E205BE5 		ldrb	r2, [fp, #-14]	@ zero_extendqisi2
 3442 0418 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3443 041c 030052E1 		cmp	r2, r3
 3444 0420 0300001A 		bne	.L20
 3445              		.loc 1 80 0 is_stmt 0 discriminator 2
 3446 0424 0F205BE5 		ldrb	r2, [fp, #-15]	@ zero_extendqisi2
 3447 0428 16305BE5 		ldrb	r3, [fp, #-22]	@ zero_extendqisi2
 3448 042c 030052E1 		cmp	r2, r3
 3449 0430 1900000A 		beq	.L21
 3450              	.L20:
 3451              		.loc 1 80 0 discriminator 1
 3452 0434 AC309FE5 		ldr	r3, .L24
 3453 0438 002093E5 		ldr	r2, [r3, #0]
 3454 043c 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3455 0440 8332A0E1 		mov	r3, r3, asl #5
 3456 0444 032082E0 		add	r2, r2, r3
 3457 0448 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3458 044c 8330A0E1 		mov	r3, r3, asl #1
 3459 0450 033082E0 		add	r3, r2, r3
 3460 0454 B030D3E1 		ldrh	r3, [r3, #0]
 3461 0458 0300A0E1 		mov	r0, r3
 3462 045c 05FFFFEB 		bl	celda_leer_valor
 3463 0460 0030A0E1 		mov	r3, r0
 3464 0464 17205BE5 		ldrb	r2, [fp, #-23]	@ zero_extendqisi2
 3465 0468 030052E1 		cmp	r2, r3
 3466 046c 0A00001A 		bne	.L21
  81:../button.c   **** 			{
  82:../button.c   **** 				celda_marcar_error(&cuadricula[f][c]);
 3467              		.loc 1 82 0 is_stmt 1
 3468 0470 70309FE5 		ldr	r3, .L24
 3469 0474 003093E5 		ldr	r3, [r3, #0]
 3470 0478 0320A0E1 		mov	r2, r3
 3471 047c 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3472 0480 0312A0E1 		mov	r1, r3, asl #4
 3473 0484 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3474 0488 033081E0 		add	r3, r1, r3
 3475 048c 8330A0E1 		mov	r3, r3, asl #1
 3476 0490 033082E0 		add	r3, r2, r3
 3477 0494 0300A0E1 		mov	r0, r3
 3478 0498 27FFFFEB 		bl	celda_marcar_error
 3479              	.L21:
  78:../button.c   **** 		for (c = region_col_inicio; c < region_col_inicio + 3; c++)
 3480              		.loc 1 78 0
 3481 049c 0F305BE5 		ldrb	r3, [fp, #-15]
 3482 04a0 013083E2 		add	r3, r3, #1
 3483 04a4 0F304BE5 		strb	r3, [fp, #-15]
 3484              	.L19:
  78:../button.c   **** 		for (c = region_col_inicio; c < region_col_inicio + 3; c++)
 3485              		.loc 1 78 0 is_stmt 0 discriminator 1
 3486 04a8 0F205BE5 		ldrb	r2, [fp, #-15]	@ zero_extendqisi2
 3487 04ac 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3488 04b0 033083E2 		add	r3, r3, #3
 3489 04b4 030052E1 		cmp	r2, r3
 3490 04b8 D5FFFFBA 		blt	.L22
  76:../button.c   **** 	for (f = region_fila_inicio; f < region_fila_inicio + 3; f++)
 3491              		.loc 1 76 0 is_stmt 1
 3492 04bc 0E305BE5 		ldrb	r3, [fp, #-14]
 3493 04c0 013083E2 		add	r3, r3, #1
 3494 04c4 0E304BE5 		strb	r3, [fp, #-14]
 3495              	.L18:
  76:../button.c   **** 	for (f = region_fila_inicio; f < region_fila_inicio + 3; f++)
 3496              		.loc 1 76 0 is_stmt 0 discriminator 1
 3497 04c8 0E205BE5 		ldrb	r2, [fp, #-14]	@ zero_extendqisi2
 3498 04cc 10305BE5 		ldrb	r3, [fp, #-16]	@ zero_extendqisi2
 3499 04d0 033083E2 		add	r3, r3, #3
 3500 04d4 030052E1 		cmp	r2, r3
 3501 04d8 CAFFFFBA 		blt	.L23
  83:../button.c   **** 			}
  84:../button.c   **** 		}
  85:../button.c   **** 	}
  86:../button.c   **** }
 3502              		.loc 1 86 0 is_stmt 1
 3503 04dc 0CD04BE2 		sub	sp, fp, #12
 3504 04e0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3505 04e4 1EFF2FE1 		bx	lr
 3506              	.L25:
 3507              		.align	2
 3508              	.L24:
 3509 04e8 00000000 		.word	cuadricula
 3510 04ec ABAAAAAA 		.word	-1431655765
 3511              		.cfi_endproc
 3512              	.LFE7:
 3514              		.align	2
 3516              	boton_confirmado:
 3517              	.LFB8:
  87:../button.c   **** 
  88:../button.c   **** /* Callback para recibir la confirmación de pulsaciones filtradas por el timer3 */
  89:../button.c   **** static void boton_confirmado(uint8_t boton_id) // MODIFICAR FUNCIONES ACTUALIZAR Y PROPAGAR SEGUN L
  90:../button.c   **** {
 3518              		.loc 1 90 0
 3519              		.cfi_startproc
 3520              		@ Function supports interworking.
 3521              		@ args = 0, pretend = 0, frame = 16
 3522              		@ frame_needed = 1, uses_anonymous_args = 0
 3523 04f0 0DC0A0E1 		mov	ip, sp
 3524              	.LCFI14:
 3525              		.cfi_def_cfa_register 12
 3526 04f4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3527 04f8 04B04CE2 		sub	fp, ip, #4
 3528              		.cfi_offset 14, -8
 3529              		.cfi_offset 13, -12
 3530              		.cfi_offset 11, -16
 3531              	.LCFI15:
 3532              		.cfi_def_cfa 11, 4
 3533 04fc 10D04DE2 		sub	sp, sp, #16
 3534 0500 0030A0E1 		mov	r3, r0
 3535 0504 15304BE5 		strb	r3, [fp, #-21]
  91:../button.c   ****         cola_depuracion(timer2_count(), boton_id, estado_juego);
 3536              		.loc 1 91 0
 3537 0508 FEFFFFEB 		bl	timer2_count
 3538 050c 0010A0E1 		mov	r1, r0
 3539 0510 4C389FE5 		ldr	r3, .L68
 3540 0514 0030D3E5 		ldrb	r3, [r3, #0]
 3541 0518 FF3003E2 		and	r3, r3, #255
 3542 051c 15205BE5 		ldrb	r2, [fp, #-21]	@ zero_extendqisi2
 3543 0520 0100A0E1 		mov	r0, r1
 3544 0524 0210A0E1 		mov	r1, r2
 3545 0528 0320A0E1 		mov	r2, r3
 3546 052c FEFFFFEB 		bl	cola_depuracion
  92:../button.c   ****         
  93:../button.c   ****         switch (estado_juego)
 3547              		.loc 1 93 0
 3548 0530 2C389FE5 		ldr	r3, .L68
 3549 0534 0030D3E5 		ldrb	r3, [r3, #0]
 3550 0538 FF3003E2 		and	r3, r3, #255
 3551 053c 070053E3 		cmp	r3, #7
 3552 0540 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3553 0544 030200EA 		b	.L26
 3554              	.L35:
 3555 0548 68050000 		.word	.L28
 3556 054c D8050000 		.word	.L29
 3557 0550 C8060000 		.word	.L30
 3558 0554 88070000 		.word	.L31
 3559 0558 10080000 		.word	.L32
 3560 055c B0080000 		.word	.L33
 3561 0560 580D0000 		.word	.L26
 3562 0564 E40C0000 		.word	.L34
 3563              	.L28:
  94:../button.c   ****         {
  95:../button.c   ****                 case ESPERANDO_INICIO:
  96:../button.c   ****                         /* Cualquier botón inicia el juego */
  97:../button.c   ****                         /* Guardar tiempo de inicio para reiniciar el contador */
  98:../button.c   ****                         tiempo_inicio = timer2_count();
 3564              		.loc 1 98 0
 3565 0568 FEFFFFEB 		bl	timer2_count
 3566 056c 0020A0E1 		mov	r2, r0
 3567 0570 F0379FE5 		ldr	r3, .L68+4
 3568 0574 002083E5 		str	r2, [r3, #0]
  99:../button.c   ****                         
 100:../button.c   ****                         /* Calcular candidatos por primera vez */
 101:../button.c   ****                         celdas_vacias = candidatos_actualizar_all(cuadricula);
 3569              		.loc 1 101 0
 3570 0578 EC379FE5 		ldr	r3, .L68+8
 3571 057c 003093E5 		ldr	r3, [r3, #0]
 3572 0580 0300A0E1 		mov	r0, r3
 3573 0584 FEFFFFEB 		bl	candidatos_actualizar_all
 3574 0588 0020A0E1 		mov	r2, r0
 3575 058c DC379FE5 		ldr	r3, .L68+12
 3576 0590 002083E5 		str	r2, [r3, #0]
 102:../button.c   ****                         
 103:../button.c   ****                         /* Dibujar el tablero del juego */
 104:../button.c   ****                         Sudoku_Dibujar_Tablero();
 3577              		.loc 1 104 0
 3578 0594 FEFFFFEB 		bl	Sudoku_Dibujar_Tablero
 105:../button.c   ****                         
 106:../button.c   ****                         /* Actualizar con los valores de la cuadrícula */
 107:../button.c   ****                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3579              		.loc 1 107 0
 3580 0598 CC379FE5 		ldr	r3, .L68+8
 3581 059c 003093E5 		ldr	r3, [r3, #0]
 3582 05a0 0300A0E1 		mov	r0, r3
 3583 05a4 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 108:../button.c   ****                         
 109:../button.c   ****                         /* Pasar a introducir fila */
 110:../button.c   ****                         estado_juego = INTRODUCIR_FILA;
 3584              		.loc 1 110 0
 3585 05a8 B4379FE5 		ldr	r3, .L68
 3586 05ac 0120A0E3 		mov	r2, #1
 3587 05b0 0020C3E5 		strb	r2, [r3, #0]
 111:../button.c   ****                         int_count = 9;  /* Iniciar en 9 para que al incrementar vaya a 0 */
 3588              		.loc 1 111 0
 3589 05b4 B8379FE5 		ldr	r3, .L68+16
 3590 05b8 0920A0E3 		mov	r2, #9
 3591 05bc 0020C3E5 		strb	r2, [r3, #0]
 112:../button.c   ****                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 3592              		.loc 1 112 0
 3593 05c0 0F00A0E3 		mov	r0, #15
 3594 05c4 FEFFFFEB 		bl	D8Led_symbol
 113:../button.c   ****                         pantalla_mostrada = 0;  /* Resetear flag para próxima partida */
 3595              		.loc 1 113 0
 3596 05c8 A8379FE5 		ldr	r3, .L68+20
 3597 05cc 0020A0E3 		mov	r2, #0
 3598 05d0 0020C3E5 		strb	r2, [r3, #0]
 114:../button.c   ****                         break;
 3599              		.loc 1 114 0
 3600 05d4 DF0100EA 		b	.L26
 3601              	.L29:
 115:../button.c   ****                 
 116:../button.c   ****                 case INTRODUCIR_FILA:
 117:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3602              		.loc 1 117 0
 3603 05d8 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3604 05dc 080053E3 		cmp	r3, #8
 3605 05e0 1500001A 		bne	.L36
 118:../button.c   ****                         {
 119:../button.c   ****                                 /* Incrementar fila (ciclo: 0 → 1 → 2 → ... → 9 → 0) */
 120:../button.c   ****                                 int_count++;
 3606              		.loc 1 120 0
 3607 05e4 88379FE5 		ldr	r3, .L68+16
 3608 05e8 0030D3E5 		ldrb	r3, [r3, #0]
 3609 05ec FF3003E2 		and	r3, r3, #255
 3610 05f0 013083E2 		add	r3, r3, #1
 3611 05f4 FF2003E2 		and	r2, r3, #255
 3612 05f8 74379FE5 		ldr	r3, .L68+16
 3613 05fc 0020C3E5 		strb	r2, [r3, #0]
 121:../button.c   ****                                 if (int_count > 9)
 3614              		.loc 1 121 0
 3615 0600 6C379FE5 		ldr	r3, .L68+16
 3616 0604 0030D3E5 		ldrb	r3, [r3, #0]
 3617 0608 FF3003E2 		and	r3, r3, #255
 3618 060c 090053E3 		cmp	r3, #9
 3619 0610 0200009A 		bls	.L37
 122:../button.c   ****                                 {
 123:../button.c   ****                                         int_count = 0;  /* Volver a 0 */
 3620              		.loc 1 123 0
 3621 0614 58379FE5 		ldr	r3, .L68+16
 3622 0618 0020A0E3 		mov	r2, #0
 3623 061c 0020C3E5 		strb	r2, [r3, #0]
 3624              	.L37:
 124:../button.c   ****                                 }
 125:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3625              		.loc 1 125 0
 3626 0620 4C379FE5 		ldr	r3, .L68+16
 3627 0624 0030D3E5 		ldrb	r3, [r3, #0]
 3628 0628 FF3003E2 		and	r3, r3, #255
 3629 062c 0F3003E2 		and	r3, r3, #15
 3630 0630 0300A0E1 		mov	r0, r3
 3631 0634 FEFFFFEB 		bl	D8Led_symbol
 126:../button.c   ****                         }
 127:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 128:../button.c   ****                         {
 129:../button.c   ****                                 /* Verificar si se eligió fila 0 (terminar partida) */
 130:../button.c   ****                                 if (int_count == 0)
 131:../button.c   ****                                 {
 132:../button.c   ****                                         /* Fila 0: terminar la partida */
 133:../button.c   ****                                         /* Guardar tiempo transcurrido desde el inicio de esta part
 134:../button.c   ****                                         tiempo_final = timer2_count() - tiempo_inicio;
 135:../button.c   ****                                         estado_juego = PARTIDA_TERMINADA;
 136:../button.c   ****                                         /* La pantalla final se mostrará en este estado */
 137:../button.c   ****                                 }
 138:../button.c   ****                                 else
 139:../button.c   ****                                 {
 140:../button.c   ****                                         /* Confirmar fila y pasar a introducir columna */
 141:../button.c   ****                                         fila = int_count - 1;  /* Convertir a índice 0-8 */
 142:../button.c   ****                                         estado_juego = INTRODUCIR_COLUMNA;
 143:../button.c   ****                                         int_count = 0;
 144:../button.c   ****                                         D8Led_symbol(12);  /* Mostrar 'C' de Columna (índice 12 en
 145:../button.c   ****                                 }
 146:../button.c   ****                         }
 147:../button.c   ****                         break;
 3632              		.loc 1 147 0
 3633 0638 C60100EA 		b	.L26
 3634              	.L36:
 127:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3635              		.loc 1 127 0
 3636 063c 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3637 0640 040053E3 		cmp	r3, #4
 3638 0644 BE01001A 		bne	.L65
 130:../button.c   ****                                 if (int_count == 0)
 3639              		.loc 1 130 0
 3640 0648 24379FE5 		ldr	r3, .L68+16
 3641 064c 0030D3E5 		ldrb	r3, [r3, #0]
 3642 0650 FF3003E2 		and	r3, r3, #255
 3643 0654 000053E3 		cmp	r3, #0
 3644 0658 0A00001A 		bne	.L39
 134:../button.c   ****                                         tiempo_final = timer2_count() - tiempo_inicio;
 3645              		.loc 1 134 0
 3646 065c FEFFFFEB 		bl	timer2_count
 3647 0660 0020A0E1 		mov	r2, r0
 3648 0664 FC369FE5 		ldr	r3, .L68+4
 3649 0668 003093E5 		ldr	r3, [r3, #0]
 3650 066c 022063E0 		rsb	r2, r3, r2
 3651 0670 04379FE5 		ldr	r3, .L68+24
 3652 0674 002083E5 		str	r2, [r3, #0]
 135:../button.c   ****                                         estado_juego = PARTIDA_TERMINADA;
 3653              		.loc 1 135 0
 3654 0678 E4369FE5 		ldr	r3, .L68
 3655 067c 0720A0E3 		mov	r2, #7
 3656 0680 0020C3E5 		strb	r2, [r3, #0]
 3657              		.loc 1 147 0
 3658 0684 B30100EA 		b	.L26
 3659              	.L39:
 141:../button.c   ****                                         fila = int_count - 1;  /* Convertir a índice 0-8 */
 3660              		.loc 1 141 0
 3661 0688 E4369FE5 		ldr	r3, .L68+16
 3662 068c 0030D3E5 		ldrb	r3, [r3, #0]
 3663 0690 FF3003E2 		and	r3, r3, #255
 3664 0694 013043E2 		sub	r3, r3, #1
 3665 0698 FF2003E2 		and	r2, r3, #255
 3666 069c DC369FE5 		ldr	r3, .L68+28
 3667 06a0 0020C3E5 		strb	r2, [r3, #0]
 142:../button.c   ****                                         estado_juego = INTRODUCIR_COLUMNA;
 3668              		.loc 1 142 0
 3669 06a4 B8369FE5 		ldr	r3, .L68
 3670 06a8 0220A0E3 		mov	r2, #2
 3671 06ac 0020C3E5 		strb	r2, [r3, #0]
 143:../button.c   ****                                         int_count = 0;
 3672              		.loc 1 143 0
 3673 06b0 BC369FE5 		ldr	r3, .L68+16
 3674 06b4 0020A0E3 		mov	r2, #0
 3675 06b8 0020C3E5 		strb	r2, [r3, #0]
 144:../button.c   ****                                         D8Led_symbol(12);  /* Mostrar 'C' de Columna (índice 12 en
 3676              		.loc 1 144 0
 3677 06bc 0C00A0E3 		mov	r0, #12
 3678 06c0 FEFFFFEB 		bl	D8Led_symbol
 3679              		.loc 1 147 0
 3680 06c4 A30100EA 		b	.L26
 3681              	.L30:
 148:../button.c   ****                 
 149:../button.c   ****                 case INTRODUCIR_COLUMNA:
 150:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3682              		.loc 1 150 0
 3683 06c8 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3684 06cc 080053E3 		cmp	r3, #8
 3685 06d0 1500001A 		bne	.L40
 151:../button.c   ****                         {
 152:../button.c   ****                                 /* Incrementar columna */
 153:../button.c   ****                                 int_count++;
 3686              		.loc 1 153 0
 3687 06d4 98369FE5 		ldr	r3, .L68+16
 3688 06d8 0030D3E5 		ldrb	r3, [r3, #0]
 3689 06dc FF3003E2 		and	r3, r3, #255
 3690 06e0 013083E2 		add	r3, r3, #1
 3691 06e4 FF2003E2 		and	r2, r3, #255
 3692 06e8 84369FE5 		ldr	r3, .L68+16
 3693 06ec 0020C3E5 		strb	r2, [r3, #0]
 154:../button.c   ****                                 if (int_count > 9)
 3694              		.loc 1 154 0
 3695 06f0 7C369FE5 		ldr	r3, .L68+16
 3696 06f4 0030D3E5 		ldrb	r3, [r3, #0]
 3697 06f8 FF3003E2 		and	r3, r3, #255
 3698 06fc 090053E3 		cmp	r3, #9
 3699 0700 0200009A 		bls	.L41
 155:../button.c   ****                                 {
 156:../button.c   ****                                         int_count = 1;
 3700              		.loc 1 156 0
 3701 0704 68369FE5 		ldr	r3, .L68+16
 3702 0708 0120A0E3 		mov	r2, #1
 3703 070c 0020C3E5 		strb	r2, [r3, #0]
 3704              	.L41:
 157:../button.c   ****                                 }
 158:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3705              		.loc 1 158 0
 3706 0710 5C369FE5 		ldr	r3, .L68+16
 3707 0714 0030D3E5 		ldrb	r3, [r3, #0]
 3708 0718 FF3003E2 		and	r3, r3, #255
 3709 071c 0F3003E2 		and	r3, r3, #15
 3710 0720 0300A0E1 		mov	r0, r3
 3711 0724 FEFFFFEB 		bl	D8Led_symbol
 159:../button.c   ****                         }
 160:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 161:../button.c   ****                         {
 162:../button.c   ****                                 /* Confirmar columna y pasar a introducir valor */
 163:../button.c   ****                                 columna = int_count - 1;  /* Convertir a índice 0-8 */
 164:../button.c   ****                                 estado_juego = VERIFICAR_CELDA;
 165:../button.c   ****                                 int_count = 0;
 166:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 167:../button.c   ****                         }
 168:../button.c   ****                         break;
 3712              		.loc 1 168 0
 3713 0728 8A0100EA 		b	.L26
 3714              	.L40:
 160:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3715              		.loc 1 160 0
 3716 072c 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3717 0730 040053E3 		cmp	r3, #4
 3718 0734 8401001A 		bne	.L66
 163:../button.c   ****                                 columna = int_count - 1;  /* Convertir a índice 0-8 */
 3719              		.loc 1 163 0
 3720 0738 34369FE5 		ldr	r3, .L68+16
 3721 073c 0030D3E5 		ldrb	r3, [r3, #0]
 3722 0740 FF3003E2 		and	r3, r3, #255
 3723 0744 013043E2 		sub	r3, r3, #1
 3724 0748 FF2003E2 		and	r2, r3, #255
 3725 074c 30369FE5 		ldr	r3, .L68+32
 3726 0750 0020C3E5 		strb	r2, [r3, #0]
 164:../button.c   ****                                 estado_juego = VERIFICAR_CELDA;
 3727              		.loc 1 164 0
 3728 0754 08369FE5 		ldr	r3, .L68
 3729 0758 0320A0E3 		mov	r2, #3
 3730 075c 0020C3E5 		strb	r2, [r3, #0]
 165:../button.c   ****                                 int_count = 0;
 3731              		.loc 1 165 0
 3732 0760 0C369FE5 		ldr	r3, .L68+16
 3733 0764 0020A0E3 		mov	r2, #0
 3734 0768 0020C3E5 		strb	r2, [r3, #0]
 166:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3735              		.loc 1 166 0
 3736 076c 00369FE5 		ldr	r3, .L68+16
 3737 0770 0030D3E5 		ldrb	r3, [r3, #0]
 3738 0774 FF3003E2 		and	r3, r3, #255
 3739 0778 0F3003E2 		and	r3, r3, #15
 3740 077c 0300A0E1 		mov	r0, r3
 3741 0780 FEFFFFEB 		bl	D8Led_symbol
 3742              		.loc 1 168 0
 3743 0784 730100EA 		b	.L26
 3744              	.L31:
 169:../button.c   ****                 
 170:../button.c   ****                 case VERIFICAR_CELDA:
 171:../button.c   ****                         /* Primero se verifica si la celda[fila][columna] no es una pista */
 172:../button.c   ****                         if (celda_es_pista(cuadricula[fila][columna]))
 3745              		.loc 1 172 0
 3746 0788 DC359FE5 		ldr	r3, .L68+8
 3747 078c 002093E5 		ldr	r2, [r3, #0]
 3748 0790 E8359FE5 		ldr	r3, .L68+28
 3749 0794 0030D3E5 		ldrb	r3, [r3, #0]
 3750 0798 FF3003E2 		and	r3, r3, #255
 3751 079c 8332A0E1 		mov	r3, r3, asl #5
 3752 07a0 032082E0 		add	r2, r2, r3
 3753 07a4 D8359FE5 		ldr	r3, .L68+32
 3754 07a8 0030D3E5 		ldrb	r3, [r3, #0]
 3755 07ac FF3003E2 		and	r3, r3, #255
 3756 07b0 8330A0E1 		mov	r3, r3, asl #1
 3757 07b4 033082E0 		add	r3, r2, r3
 3758 07b8 B030D3E1 		ldrh	r3, [r3, #0]
 3759 07bc 0300A0E1 		mov	r0, r3
 3760 07c0 4EFEFFEB 		bl	celda_es_pista
 3761 07c4 0030A0E1 		mov	r3, r0
 3762 07c8 000053E3 		cmp	r3, #0
 3763 07cc 0800000A 		beq	.L43
 173:../button.c   ****                         {
 174:../button.c   ****                                 // Se vuelve al estado INTRODUCIR_FILA
 175:../button.c   ****                                 estado_juego = INTRODUCIR_FILA;
 3764              		.loc 1 175 0
 3765 07d0 8C359FE5 		ldr	r3, .L68
 3766 07d4 0120A0E3 		mov	r2, #1
 3767 07d8 0020C3E5 		strb	r2, [r3, #0]
 176:../button.c   ****                                 int_count = 0;
 3768              		.loc 1 176 0
 3769 07dc 90359FE5 		ldr	r3, .L68+16
 3770 07e0 0020A0E3 		mov	r2, #0
 3771 07e4 0020C3E5 		strb	r2, [r3, #0]
 177:../button.c   ****                                 D8Led_symbol(15);  /* Mostrar 'F' de Fila (índice 15 en el array S
 3772              		.loc 1 177 0
 3773 07e8 0F00A0E3 		mov	r0, #15
 3774 07ec FEFFFFEB 		bl	D8Led_symbol
 178:../button.c   ****                         } 
 179:../button.c   ****                         else
 180:../button.c   ****                         {
 181:../button.c   ****                                 // Si no es pista, se pasa a INTRODUCIR_VALOR
 182:../button.c   ****                                 estado_juego = INTRODUCIR_VALOR;
 183:../button.c   ****                                 int_count = 0;
 184:../button.c   ****                         }
 185:../button.c   ****                         break;
 3775              		.loc 1 185 0
 3776 07f0 580100EA 		b	.L26
 3777              	.L43:
 182:../button.c   ****                                 estado_juego = INTRODUCIR_VALOR;
 3778              		.loc 1 182 0
 3779 07f4 68359FE5 		ldr	r3, .L68
 3780 07f8 0420A0E3 		mov	r2, #4
 3781 07fc 0020C3E5 		strb	r2, [r3, #0]
 183:../button.c   ****                                 int_count = 0;
 3782              		.loc 1 183 0
 3783 0800 6C359FE5 		ldr	r3, .L68+16
 3784 0804 0020A0E3 		mov	r2, #0
 3785 0808 0020C3E5 		strb	r2, [r3, #0]
 3786              		.loc 1 185 0
 3787 080c 510100EA 		b	.L26
 3788              	.L32:
 186:../button.c   ****                 
 187:../button.c   ****                 case INTRODUCIR_VALOR:
 188:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3789              		.loc 1 188 0
 3790 0810 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3791 0814 080053E3 		cmp	r3, #8
 3792 0818 1500001A 		bne	.L45
 189:../button.c   ****                         {
 190:../button.c   ****                                 /* Incrementar valor */
 191:../button.c   ****                                 int_count++;
 3793              		.loc 1 191 0
 3794 081c 50359FE5 		ldr	r3, .L68+16
 3795 0820 0030D3E5 		ldrb	r3, [r3, #0]
 3796 0824 FF3003E2 		and	r3, r3, #255
 3797 0828 013083E2 		add	r3, r3, #1
 3798 082c FF2003E2 		and	r2, r3, #255
 3799 0830 3C359FE5 		ldr	r3, .L68+16
 3800 0834 0020C3E5 		strb	r2, [r3, #0]
 192:../button.c   ****                                 if (int_count > 9)
 3801              		.loc 1 192 0
 3802 0838 34359FE5 		ldr	r3, .L68+16
 3803 083c 0030D3E5 		ldrb	r3, [r3, #0]
 3804 0840 FF3003E2 		and	r3, r3, #255
 3805 0844 090053E3 		cmp	r3, #9
 3806 0848 0200009A 		bls	.L46
 193:../button.c   ****                                 {
 194:../button.c   ****                                         int_count = 0;
 3807              		.loc 1 194 0
 3808 084c 20359FE5 		ldr	r3, .L68+16
 3809 0850 0020A0E3 		mov	r2, #0
 3810 0854 0020C3E5 		strb	r2, [r3, #0]
 3811              	.L46:
 195:../button.c   ****                                 }
 196:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3812              		.loc 1 196 0
 3813 0858 14359FE5 		ldr	r3, .L68+16
 3814 085c 0030D3E5 		ldrb	r3, [r3, #0]
 3815 0860 FF3003E2 		and	r3, r3, #255
 3816 0864 0F3003E2 		and	r3, r3, #15
 3817 0868 0300A0E1 		mov	r0, r3
 3818 086c FEFFFFEB 		bl	D8Led_symbol
 197:../button.c   ****                         }
 198:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 199:../button.c   ****                         {
 200:../button.c   ****                                 /* Confirmar valor e intentar escribir en la celda */
 201:../button.c   ****                                 valor = int_count;  /* Valor a escribir (0-9) */
 202:../button.c   ****                                 
 203:../button.c   ****                                 estado_juego = VERIFICAR_VALOR;
 204:../button.c   ****                                 int_count = 0;
 205:../button.c   ****                         }
 206:../button.c   ****                         break;
 3819              		.loc 1 206 0
 3820 0870 380100EA 		b	.L26
 3821              	.L45:
 198:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3822              		.loc 1 198 0
 3823 0874 15305BE5 		ldrb	r3, [fp, #-21]	@ zero_extendqisi2
 3824 0878 040053E3 		cmp	r3, #4
 3825 087c 3401001A 		bne	.L67
 201:../button.c   ****                                 valor = int_count;  /* Valor a escribir (0-9) */
 3826              		.loc 1 201 0
 3827 0880 EC349FE5 		ldr	r3, .L68+16
 3828 0884 0030D3E5 		ldrb	r3, [r3, #0]
 3829 0888 FF2003E2 		and	r2, r3, #255
 3830 088c F4349FE5 		ldr	r3, .L68+36
 3831 0890 0020C3E5 		strb	r2, [r3, #0]
 203:../button.c   ****                                 estado_juego = VERIFICAR_VALOR;
 3832              		.loc 1 203 0
 3833 0894 C8349FE5 		ldr	r3, .L68
 3834 0898 0520A0E3 		mov	r2, #5
 3835 089c 0020C3E5 		strb	r2, [r3, #0]
 204:../button.c   ****                                 int_count = 0;
 3836              		.loc 1 204 0
 3837 08a0 CC349FE5 		ldr	r3, .L68+16
 3838 08a4 0020A0E3 		mov	r2, #0
 3839 08a8 0020C3E5 		strb	r2, [r3, #0]
 3840              		.loc 1 206 0
 3841 08ac 290100EA 		b	.L26
 3842              	.L33:
 207:../button.c   ****                 
 208:../button.c   ****                 case VERIFICAR_VALOR:
 209:../button.c   ****                         /* Guardar valor previo de la celda */
 210:../button.c   ****                         valor_previo = celda_leer_valor(cuadricula[fila][columna]);
 3843              		.loc 1 210 0
 3844 08b0 B4349FE5 		ldr	r3, .L68+8
 3845 08b4 002093E5 		ldr	r2, [r3, #0]
 3846 08b8 C0349FE5 		ldr	r3, .L68+28
 3847 08bc 0030D3E5 		ldrb	r3, [r3, #0]
 3848 08c0 FF3003E2 		and	r3, r3, #255
 3849 08c4 8332A0E1 		mov	r3, r3, asl #5
 3850 08c8 032082E0 		add	r2, r2, r3
 3851 08cc B0349FE5 		ldr	r3, .L68+32
 3852 08d0 0030D3E5 		ldrb	r3, [r3, #0]
 3853 08d4 FF3003E2 		and	r3, r3, #255
 3854 08d8 8330A0E1 		mov	r3, r3, asl #1
 3855 08dc 033082E0 		add	r3, r2, r3
 3856 08e0 B030D3E1 		ldrh	r3, [r3, #0]
 3857 08e4 0300A0E1 		mov	r0, r3
 3858 08e8 E2FDFFEB 		bl	celda_leer_valor
 3859 08ec 0030A0E1 		mov	r3, r0
 3860 08f0 0320A0E1 		mov	r2, r3
 3861 08f4 90349FE5 		ldr	r3, .L68+40
 3862 08f8 0020C3E5 		strb	r2, [r3, #0]
 211:../button.c   ****                         
 212:../button.c   ****                         if (valor == 0)
 3863              		.loc 1 212 0
 3864 08fc 84349FE5 		ldr	r3, .L68+36
 3865 0900 0030D3E5 		ldrb	r3, [r3, #0]
 3866 0904 FF3003E2 		and	r3, r3, #255
 3867 0908 000053E3 		cmp	r3, #0
 3868 090c 4000001A 		bne	.L48
 3869              	.LBB2:
 213:../button.c   ****                         {
 214:../button.c   ****                                 uint8_t f, c;
 215:../button.c   ****                                 
 216:../button.c   ****                                 /* Valor 0 = borrar -> pasar a BORRAR_VALOR */
 217:../button.c   ****                                 /* Limpiar todos los errores previos */
 218:../button.c   ****                                 for (f = 0; f < NUM_FILAS; f++)
 3870              		.loc 1 218 0
 3871 0910 0030A0E3 		mov	r3, #0
 3872 0914 0D304BE5 		strb	r3, [fp, #-13]
 3873 0918 160000EA 		b	.L49
 3874              	.L52:
 219:../button.c   ****                                 {
 220:../button.c   ****                                         for (c = 0; c < NUM_COLUMNAS; c++)
 3875              		.loc 1 220 0
 3876 091c 0030A0E3 		mov	r3, #0
 3877 0920 0E304BE5 		strb	r3, [fp, #-14]
 3878 0924 0D0000EA 		b	.L50
 3879              	.L51:
 221:../button.c   ****                                         {
 222:../button.c   ****                                                 celda_limpiar_error(&cuadricula[f][c]);
 3880              		.loc 1 222 0 discriminator 2
 3881 0928 3C349FE5 		ldr	r3, .L68+8
 3882 092c 003093E5 		ldr	r3, [r3, #0]
 3883 0930 0320A0E1 		mov	r2, r3
 3884 0934 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3885 0938 0312A0E1 		mov	r1, r3, asl #4
 3886 093c 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3887 0940 033081E0 		add	r3, r1, r3
 3888 0944 8330A0E1 		mov	r3, r3, asl #1
 3889 0948 033082E0 		add	r3, r2, r3
 3890 094c 0300A0E1 		mov	r0, r3
 3891 0950 08FEFFEB 		bl	celda_limpiar_error
 220:../button.c   ****                                         for (c = 0; c < NUM_COLUMNAS; c++)
 3892              		.loc 1 220 0 discriminator 2
 3893 0954 0E305BE5 		ldrb	r3, [fp, #-14]
 3894 0958 013083E2 		add	r3, r3, #1
 3895 095c 0E304BE5 		strb	r3, [fp, #-14]
 3896              	.L50:
 220:../button.c   ****                                         for (c = 0; c < NUM_COLUMNAS; c++)
 3897              		.loc 1 220 0 is_stmt 0 discriminator 1
 3898 0960 0E305BE5 		ldrb	r3, [fp, #-14]	@ zero_extendqisi2
 3899 0964 0F0053E3 		cmp	r3, #15
 3900 0968 EEFFFF9A 		bls	.L51
 218:../button.c   ****                                 for (f = 0; f < NUM_FILAS; f++)
 3901              		.loc 1 218 0 is_stmt 1
 3902 096c 0D305BE5 		ldrb	r3, [fp, #-13]
 3903 0970 013083E2 		add	r3, r3, #1
 3904 0974 0D304BE5 		strb	r3, [fp, #-13]
 3905              	.L49:
 218:../button.c   ****                                 for (f = 0; f < NUM_FILAS; f++)
 3906              		.loc 1 218 0 is_stmt 0 discriminator 1
 3907 0978 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3908 097c 080053E3 		cmp	r3, #8
 3909 0980 E5FFFF9A 		bls	.L52
 223:../button.c   ****                                         }
 224:../button.c   ****                                 }
 225:../button.c   ****                                 
 226:../button.c   ****                                 /* Borrar el valor de la celda */
 227:../button.c   ****                                 celda_poner_valor(&cuadricula[fila][columna], 0);
 3910              		.loc 1 227 0 is_stmt 1
 3911 0984 E0339FE5 		ldr	r3, .L68+8
 3912 0988 003093E5 		ldr	r3, [r3, #0]
 3913 098c 0320A0E1 		mov	r2, r3
 3914 0990 E8339FE5 		ldr	r3, .L68+28
 3915 0994 0030D3E5 		ldrb	r3, [r3, #0]
 3916 0998 FF3003E2 		and	r3, r3, #255
 3917 099c 0312A0E1 		mov	r1, r3, asl #4
 3918 09a0 DC339FE5 		ldr	r3, .L68+32
 3919 09a4 0030D3E5 		ldrb	r3, [r3, #0]
 3920 09a8 FF3003E2 		and	r3, r3, #255
 3921 09ac 033081E0 		add	r3, r1, r3
 3922 09b0 8330A0E1 		mov	r3, r3, asl #1
 3923 09b4 033082E0 		add	r3, r2, r3
 3924 09b8 0300A0E1 		mov	r0, r3
 3925 09bc 0010A0E3 		mov	r1, #0
 3926 09c0 8EFDFFEB 		bl	celda_poner_valor
 228:../button.c   ****                                 
 229:../button.c   ****                                 /* Al borrar un valor, hay que recalcular todos los candidatos */
 230:../button.c   ****                                 celdas_vacias = candidatos_actualizar_all(cuadricula);
 3927              		.loc 1 230 0
 3928 09c4 A0339FE5 		ldr	r3, .L68+8
 3929 09c8 003093E5 		ldr	r3, [r3, #0]
 3930 09cc 0300A0E1 		mov	r0, r3
 3931 09d0 FEFFFFEB 		bl	candidatos_actualizar_all
 3932 09d4 0020A0E1 		mov	r2, r0
 3933 09d8 90339FE5 		ldr	r3, .L68+12
 3934 09dc 002083E5 		str	r2, [r3, #0]
 231:../button.c   ****                                 
 232:../button.c   ****                                 /* Actualizar la visualización del tablero */
 233:../button.c   ****                                 Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3935              		.loc 1 233 0
 3936 09e0 84339FE5 		ldr	r3, .L68+8
 3937 09e4 003093E5 		ldr	r3, [r3, #0]
 3938 09e8 0300A0E1 		mov	r0, r3
 3939 09ec FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 234:../button.c   ****                                 
 235:../button.c   ****                                 /* Volver a introducir fila */
 236:../button.c   ****                                 estado_juego = INTRODUCIR_FILA;
 3940              		.loc 1 236 0
 3941 09f0 6C339FE5 		ldr	r3, .L68
 3942 09f4 0120A0E3 		mov	r2, #1
 3943 09f8 0020C3E5 		strb	r2, [r3, #0]
 237:../button.c   ****                                 int_count = 9;  /* Iniciar en 9 para que al incrementar vaya a 0 */
 3944              		.loc 1 237 0
 3945 09fc 70339FE5 		ldr	r3, .L68+16
 3946 0a00 0920A0E3 		mov	r2, #9
 3947 0a04 0020C3E5 		strb	r2, [r3, #0]
 238:../button.c   ****                                 D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 3948              		.loc 1 238 0
 3949 0a08 0F00A0E3 		mov	r0, #15
 3950 0a0c FEFFFFEB 		bl	D8Led_symbol
 239:../button.c   ****                                 break;
 3951              		.loc 1 239 0
 3952 0a10 D00000EA 		b	.L26
 3953              	.L48:
 3954              	.LBE2:
 240:../button.c   ****                         }
 241:../button.c   ****                         else
 242:../button.c   ****                         {
 243:../button.c   ****                                 /* Verificar si el valor es candidato */
 244:../button.c   ****                                 if (celda_es_candidato(cuadricula[fila][columna], valor))
 3955              		.loc 1 244 0
 3956 0a14 50339FE5 		ldr	r3, .L68+8
 3957 0a18 002093E5 		ldr	r2, [r3, #0]
 3958 0a1c 5C339FE5 		ldr	r3, .L68+28
 3959 0a20 0030D3E5 		ldrb	r3, [r3, #0]
 3960 0a24 FF3003E2 		and	r3, r3, #255
 3961 0a28 8332A0E1 		mov	r3, r3, asl #5
 3962 0a2c 032082E0 		add	r2, r2, r3
 3963 0a30 4C339FE5 		ldr	r3, .L68+32
 3964 0a34 0030D3E5 		ldrb	r3, [r3, #0]
 3965 0a38 FF3003E2 		and	r3, r3, #255
 3966 0a3c 8330A0E1 		mov	r3, r3, asl #1
 3967 0a40 033082E0 		add	r3, r2, r3
 3968 0a44 B020D3E1 		ldrh	r2, [r3, #0]
 3969 0a48 38339FE5 		ldr	r3, .L68+36
 3970 0a4c 0030D3E5 		ldrb	r3, [r3, #0]
 3971 0a50 FF3003E2 		and	r3, r3, #255
 3972 0a54 0200A0E1 		mov	r0, r2
 3973 0a58 0310A0E1 		mov	r1, r3
 3974 0a5c 93FDFFEB 		bl	celda_es_candidato
 3975 0a60 0030A0E1 		mov	r3, r0
 3976 0a64 000053E3 		cmp	r3, #0
 3977 0a68 5500000A 		beq	.L53
 3978              	.LBB3:
 245:../button.c   ****                                 {
 246:../button.c   ****                                         uint8_t f, c;
 247:../button.c   ****                                         
 248:../button.c   ****                                         /* Es candidato: escribir el valor en la celda */
 249:../button.c   ****                                         /* Primero limpiar todos los errores previos */
 250:../button.c   ****                                         for (f = 0; f < NUM_FILAS; f++)
 3979              		.loc 1 250 0
 3980 0a6c 0030A0E3 		mov	r3, #0
 3981 0a70 0F304BE5 		strb	r3, [fp, #-15]
 3982 0a74 160000EA 		b	.L54
 3983              	.L57:
 251:../button.c   ****                                         {
 252:../button.c   ****                                                 for (c = 0; c < NUM_COLUMNAS; c++)
 3984              		.loc 1 252 0
 3985 0a78 0030A0E3 		mov	r3, #0
 3986 0a7c 10304BE5 		strb	r3, [fp, #-16]
 3987 0a80 0D0000EA 		b	.L55
 3988              	.L56:
 253:../button.c   ****                                                 {
 254:../button.c   ****                                                         celda_limpiar_error(&cuadricula[f][c]);
 3989              		.loc 1 254 0 discriminator 2
 3990 0a84 E0329FE5 		ldr	r3, .L68+8
 3991 0a88 003093E5 		ldr	r3, [r3, #0]
 3992 0a8c 0320A0E1 		mov	r2, r3
 3993 0a90 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3994 0a94 0312A0E1 		mov	r1, r3, asl #4
 3995 0a98 10305BE5 		ldrb	r3, [fp, #-16]	@ zero_extendqisi2
 3996 0a9c 033081E0 		add	r3, r1, r3
 3997 0aa0 8330A0E1 		mov	r3, r3, asl #1
 3998 0aa4 033082E0 		add	r3, r2, r3
 3999 0aa8 0300A0E1 		mov	r0, r3
 4000 0aac B1FDFFEB 		bl	celda_limpiar_error
 252:../button.c   ****                                                 for (c = 0; c < NUM_COLUMNAS; c++)
 4001              		.loc 1 252 0 discriminator 2
 4002 0ab0 10305BE5 		ldrb	r3, [fp, #-16]
 4003 0ab4 013083E2 		add	r3, r3, #1
 4004 0ab8 10304BE5 		strb	r3, [fp, #-16]
 4005              	.L55:
 252:../button.c   ****                                                 for (c = 0; c < NUM_COLUMNAS; c++)
 4006              		.loc 1 252 0 is_stmt 0 discriminator 1
 4007 0abc 10305BE5 		ldrb	r3, [fp, #-16]	@ zero_extendqisi2
 4008 0ac0 0F0053E3 		cmp	r3, #15
 4009 0ac4 EEFFFF9A 		bls	.L56
 250:../button.c   ****                                         for (f = 0; f < NUM_FILAS; f++)
 4010              		.loc 1 250 0 is_stmt 1
 4011 0ac8 0F305BE5 		ldrb	r3, [fp, #-15]
 4012 0acc 013083E2 		add	r3, r3, #1
 4013 0ad0 0F304BE5 		strb	r3, [fp, #-15]
 4014              	.L54:
 250:../button.c   ****                                         for (f = 0; f < NUM_FILAS; f++)
 4015              		.loc 1 250 0 is_stmt 0 discriminator 1
 4016 0ad4 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 4017 0ad8 080053E3 		cmp	r3, #8
 4018 0adc E5FFFF9A 		bls	.L57
 255:../button.c   ****                                                 }
 256:../button.c   ****                                         }
 257:../button.c   ****                                         
 258:../button.c   ****                                         celda_poner_valor(&cuadricula[fila][columna], valor);
 4019              		.loc 1 258 0 is_stmt 1
 4020 0ae0 84329FE5 		ldr	r3, .L68+8
 4021 0ae4 003093E5 		ldr	r3, [r3, #0]
 4022 0ae8 0320A0E1 		mov	r2, r3
 4023 0aec 8C329FE5 		ldr	r3, .L68+28
 4024 0af0 0030D3E5 		ldrb	r3, [r3, #0]
 4025 0af4 FF3003E2 		and	r3, r3, #255
 4026 0af8 0312A0E1 		mov	r1, r3, asl #4
 4027 0afc 80329FE5 		ldr	r3, .L68+32
 4028 0b00 0030D3E5 		ldrb	r3, [r3, #0]
 4029 0b04 FF3003E2 		and	r3, r3, #255
 4030 0b08 033081E0 		add	r3, r1, r3
 4031 0b0c 8330A0E1 		mov	r3, r3, asl #1
 4032 0b10 032082E0 		add	r2, r2, r3
 4033 0b14 6C329FE5 		ldr	r3, .L68+36
 4034 0b18 0030D3E5 		ldrb	r3, [r3, #0]
 4035 0b1c FF3003E2 		and	r3, r3, #255
 4036 0b20 0200A0E1 		mov	r0, r2
 4037 0b24 0310A0E1 		mov	r1, r3
 4038 0b28 34FDFFEB 		bl	celda_poner_valor
 259:../button.c   ****                                         
 260:../button.c   ****                                         /* Decidir si propagar o actualizar según el caso */
 261:../button.c   ****                                         if (valor_previo != 0)
 4039              		.loc 1 261 0
 4040 0b2c 58329FE5 		ldr	r3, .L68+40
 4041 0b30 0030D3E5 		ldrb	r3, [r3, #0]
 4042 0b34 FF3003E2 		and	r3, r3, #255
 4043 0b38 000053E3 		cmp	r3, #0
 4044 0b3c 0700000A 		beq	.L58
 262:../button.c   ****                                         {
 263:../button.c   ****                                                 /* Se modificó un valor previo -> recalcular todo 
 264:../button.c   ****                                                 celdas_vacias = candidatos_actualizar_all(cuadricul
 4045              		.loc 1 264 0
 4046 0b40 24329FE5 		ldr	r3, .L68+8
 4047 0b44 003093E5 		ldr	r3, [r3, #0]
 4048 0b48 0300A0E1 		mov	r0, r3
 4049 0b4c FEFFFFEB 		bl	candidatos_actualizar_all
 4050 0b50 0020A0E1 		mov	r2, r0
 4051 0b54 14329FE5 		ldr	r3, .L68+12
 4052 0b58 002083E5 		str	r2, [r3, #0]
 4053 0b5c 0B0000EA 		b	.L59
 4054              	.L58:
 265:../button.c   ****                                         }
 266:../button.c   ****                                         else
 267:../button.c   ****                                         {
 268:../button.c   ****                                                 /* Celda vacía -> solo propagar el nuevo valor */
 269:../button.c   ****                                                 candidatos_propagar_arm(cuadricula, fila, columna);
 4055              		.loc 1 269 0
 4056 0b60 04329FE5 		ldr	r3, .L68+8
 4057 0b64 001093E5 		ldr	r1, [r3, #0]
 4058 0b68 10329FE5 		ldr	r3, .L68+28
 4059 0b6c 0030D3E5 		ldrb	r3, [r3, #0]
 4060 0b70 FF2003E2 		and	r2, r3, #255
 4061 0b74 08329FE5 		ldr	r3, .L68+32
 4062 0b78 0030D3E5 		ldrb	r3, [r3, #0]
 4063 0b7c FF3003E2 		and	r3, r3, #255
 4064 0b80 0100A0E1 		mov	r0, r1
 4065 0b84 0210A0E1 		mov	r1, r2
 4066 0b88 0320A0E1 		mov	r2, r3
 4067 0b8c FEFFFFEB 		bl	candidatos_propagar_arm
 4068              	.L59:
 270:../button.c   ****                                         }
 271:../button.c   ****                                         
 272:../button.c   ****                                         /* Actualizar la visualización del tablero */
 273:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 4069              		.loc 1 273 0
 4070 0b90 D4319FE5 		ldr	r3, .L68+8
 4071 0b94 003093E5 		ldr	r3, [r3, #0]
 4072 0b98 0300A0E1 		mov	r0, r3
 4073 0b9c FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 274:../button.c   ****                                         
 275:../button.c   ****                                         /* Volver a introducir fila */
 276:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 4074              		.loc 1 276 0
 4075 0ba0 BC319FE5 		ldr	r3, .L68
 4076 0ba4 0120A0E3 		mov	r2, #1
 4077 0ba8 0020C3E5 		strb	r2, [r3, #0]
 277:../button.c   ****                                         int_count = 9;  /* Iniciar en 9 para que al incrementar vay
 4078              		.loc 1 277 0
 4079 0bac C0319FE5 		ldr	r3, .L68+16
 4080 0bb0 0920A0E3 		mov	r2, #9
 4081 0bb4 0020C3E5 		strb	r2, [r3, #0]
 278:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 4082              		.loc 1 278 0
 4083 0bb8 0F00A0E3 		mov	r0, #15
 4084 0bbc FEFFFFEB 		bl	D8Led_symbol
 4085              	.LBE3:
 279:../button.c   ****                                 }
 280:../button.c   ****                                 else
 281:../button.c   ****                                 {
 282:../button.c   ****                                         /* No es candidato: es un error */
 283:../button.c   ****                                         /* Poner el valor incorrecto en la celda para visualizarlo 
 284:../button.c   ****                                         celda_poner_valor(&cuadricula[fila][columna], valor);
 285:../button.c   ****                                         
 286:../button.c   ****                                         /* Actualizar candidatos para reflejar el cambio */
 287:../button.c   ****                                         if (valor_previo != 0)
 288:../button.c   ****                                         {
 289:../button.c   ****                                                 /* Se modificó un valor previo -> recalcular todo 
 290:../button.c   ****                                                 celdas_vacias = candidatos_actualizar_all(cuadricul
 291:../button.c   ****                                         }
 292:../button.c   ****                                         else
 293:../button.c   ****                                         {
 294:../button.c   ****                                                 /* Celda vacía -> propagar el nuevo valor */
 295:../button.c   ****                                                 candidatos_propagar_arm(cuadricula, fila, columna);
 296:../button.c   ****                                         }
 297:../button.c   ****                                         
 298:../button.c   ****                                         /* Marcar TODAS las celdas involucradas en el conflicto */
 299:../button.c   ****                                         marcar_celdas_en_conflicto(fila, columna, valor);
 300:../button.c   ****                                         
 301:../button.c   ****                                         /* Actualizar la visualización del tablero */
 302:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 303:../button.c   ****                                         
 304:../button.c   ****                                         D8Led_symbol(14);  /* Mostrar 'E' de Error */
 305:../button.c   ****                                         
 306:../button.c   ****                                         /* Volver a introducir fila */
 307:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 308:../button.c   ****                                         int_count = 9;  /* Iniciar en 9 para que al incrementar vay
 309:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 310:../button.c   ****                                 }
 311:../button.c   ****                         }
 312:../button.c   ****                         break;
 4086              		.loc 1 312 0
 4087 0bc0 640000EA 		b	.L26
 4088              	.L53:
 284:../button.c   ****                                         celda_poner_valor(&cuadricula[fila][columna], valor);
 4089              		.loc 1 284 0
 4090 0bc4 A0319FE5 		ldr	r3, .L68+8
 4091 0bc8 003093E5 		ldr	r3, [r3, #0]
 4092 0bcc 0320A0E1 		mov	r2, r3
 4093 0bd0 A8319FE5 		ldr	r3, .L68+28
 4094 0bd4 0030D3E5 		ldrb	r3, [r3, #0]
 4095 0bd8 FF3003E2 		and	r3, r3, #255
 4096 0bdc 0312A0E1 		mov	r1, r3, asl #4
 4097 0be0 9C319FE5 		ldr	r3, .L68+32
 4098 0be4 0030D3E5 		ldrb	r3, [r3, #0]
 4099 0be8 FF3003E2 		and	r3, r3, #255
 4100 0bec 033081E0 		add	r3, r1, r3
 4101 0bf0 8330A0E1 		mov	r3, r3, asl #1
 4102 0bf4 032082E0 		add	r2, r2, r3
 4103 0bf8 88319FE5 		ldr	r3, .L68+36
 4104 0bfc 0030D3E5 		ldrb	r3, [r3, #0]
 4105 0c00 FF3003E2 		and	r3, r3, #255
 4106 0c04 0200A0E1 		mov	r0, r2
 4107 0c08 0310A0E1 		mov	r1, r3
 4108 0c0c FBFCFFEB 		bl	celda_poner_valor
 287:../button.c   ****                                         if (valor_previo != 0)
 4109              		.loc 1 287 0
 4110 0c10 74319FE5 		ldr	r3, .L68+40
 4111 0c14 0030D3E5 		ldrb	r3, [r3, #0]
 4112 0c18 FF3003E2 		and	r3, r3, #255
 4113 0c1c 000053E3 		cmp	r3, #0
 4114 0c20 0700000A 		beq	.L61
 290:../button.c   ****                                                 celdas_vacias = candidatos_actualizar_all(cuadricul
 4115              		.loc 1 290 0
 4116 0c24 40319FE5 		ldr	r3, .L68+8
 4117 0c28 003093E5 		ldr	r3, [r3, #0]
 4118 0c2c 0300A0E1 		mov	r0, r3
 4119 0c30 FEFFFFEB 		bl	candidatos_actualizar_all
 4120 0c34 0020A0E1 		mov	r2, r0
 4121 0c38 30319FE5 		ldr	r3, .L68+12
 4122 0c3c 002083E5 		str	r2, [r3, #0]
 4123 0c40 0B0000EA 		b	.L62
 4124              	.L61:
 295:../button.c   ****                                                 candidatos_propagar_arm(cuadricula, fila, columna);
 4125              		.loc 1 295 0
 4126 0c44 20319FE5 		ldr	r3, .L68+8
 4127 0c48 001093E5 		ldr	r1, [r3, #0]
 4128 0c4c 2C319FE5 		ldr	r3, .L68+28
 4129 0c50 0030D3E5 		ldrb	r3, [r3, #0]
 4130 0c54 FF2003E2 		and	r2, r3, #255
 4131 0c58 24319FE5 		ldr	r3, .L68+32
 4132 0c5c 0030D3E5 		ldrb	r3, [r3, #0]
 4133 0c60 FF3003E2 		and	r3, r3, #255
 4134 0c64 0100A0E1 		mov	r0, r1
 4135 0c68 0210A0E1 		mov	r1, r2
 4136 0c6c 0320A0E1 		mov	r2, r3
 4137 0c70 FEFFFFEB 		bl	candidatos_propagar_arm
 4138              	.L62:
 299:../button.c   ****                                         marcar_celdas_en_conflicto(fila, columna, valor);
 4139              		.loc 1 299 0
 4140 0c74 04319FE5 		ldr	r3, .L68+28
 4141 0c78 0030D3E5 		ldrb	r3, [r3, #0]
 4142 0c7c FF1003E2 		and	r1, r3, #255
 4143 0c80 FC309FE5 		ldr	r3, .L68+32
 4144 0c84 0030D3E5 		ldrb	r3, [r3, #0]
 4145 0c88 FF2003E2 		and	r2, r3, #255
 4146 0c8c F4309FE5 		ldr	r3, .L68+36
 4147 0c90 0030D3E5 		ldrb	r3, [r3, #0]
 4148 0c94 FF3003E2 		and	r3, r3, #255
 4149 0c98 0100A0E1 		mov	r0, r1
 4150 0c9c 0210A0E1 		mov	r1, r2
 4151 0ca0 0320A0E1 		mov	r2, r3
 4152 0ca4 42FDFFEB 		bl	marcar_celdas_en_conflicto
 302:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 4153              		.loc 1 302 0
 4154 0ca8 BC309FE5 		ldr	r3, .L68+8
 4155 0cac 003093E5 		ldr	r3, [r3, #0]
 4156 0cb0 0300A0E1 		mov	r0, r3
 4157 0cb4 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 304:../button.c   ****                                         D8Led_symbol(14);  /* Mostrar 'E' de Error */
 4158              		.loc 1 304 0
 4159 0cb8 0E00A0E3 		mov	r0, #14
 4160 0cbc FEFFFFEB 		bl	D8Led_symbol
 307:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 4161              		.loc 1 307 0
 4162 0cc0 9C309FE5 		ldr	r3, .L68
 4163 0cc4 0120A0E3 		mov	r2, #1
 4164 0cc8 0020C3E5 		strb	r2, [r3, #0]
 308:../button.c   ****                                         int_count = 9;  /* Iniciar en 9 para que al incrementar vay
 4165              		.loc 1 308 0
 4166 0ccc A0309FE5 		ldr	r3, .L68+16
 4167 0cd0 0920A0E3 		mov	r2, #9
 4168 0cd4 0020C3E5 		strb	r2, [r3, #0]
 309:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 4169              		.loc 1 309 0
 4170 0cd8 0F00A0E3 		mov	r0, #15
 4171 0cdc FEFFFFEB 		bl	D8Led_symbol
 4172              		.loc 1 312 0
 4173 0ce0 1C0000EA 		b	.L26
 4174              	.L34:
 313:../button.c   ****                 
 314:../button.c   ****                 case PARTIDA_TERMINADA:
 315:../button.c   ****                         /* Mostrar pantalla de despedida solo una vez */
 316:../button.c   ****                         if (!pantalla_mostrada)
 4175              		.loc 1 316 0
 4176 0ce4 8C309FE5 		ldr	r3, .L68+20
 4177 0ce8 0030D3E5 		ldrb	r3, [r3, #0]
 4178 0cec FF3003E2 		and	r3, r3, #255
 4179 0cf0 000053E3 		cmp	r3, #0
 4180 0cf4 0700001A 		bne	.L63
 317:../button.c   ****                         {
 318:../button.c   ****                                 /* Usar la función existente de lcd.c */
 319:../button.c   ****                                 Sudoku_Pantalla_Final(tiempo_final);
 4181              		.loc 1 319 0
 4182 0cf8 7C309FE5 		ldr	r3, .L68+24
 4183 0cfc 003093E5 		ldr	r3, [r3, #0]
 4184 0d00 0300A0E1 		mov	r0, r3
 4185 0d04 FEFFFFEB 		bl	Sudoku_Pantalla_Final
 320:../button.c   ****                                 
 321:../button.c   ****                                 pantalla_mostrada = 1;
 4186              		.loc 1 321 0
 4187 0d08 68309FE5 		ldr	r3, .L68+20
 4188 0d0c 0120A0E3 		mov	r2, #1
 4189 0d10 0020C3E5 		strb	r2, [r3, #0]
 322:../button.c   ****                         }
 323:../button.c   ****                         else
 324:../button.c   ****                         {
 325:../button.c   ****                                 /* Cualquier botón después de mostrar pantalla final reinicia el 
 326:../button.c   ****                                 /* Mostrar pantalla inicial */
 327:../button.c   ****                                 Sudoku_Pantalla_Inicial();
 328:../button.c   ****                                 
 329:../button.c   ****                                 /* Volver al estado inicial */
 330:../button.c   ****                                 estado_juego = ESPERANDO_INICIO;
 331:../button.c   ****                                 int_count = 0;
 332:../button.c   ****                                 pantalla_mostrada = 0;
 333:../button.c   ****                         }
 334:../button.c   ****                         break;
 4190              		.loc 1 334 0
 4191 0d14 0F0000EA 		b	.L26
 4192              	.L63:
 327:../button.c   ****                                 Sudoku_Pantalla_Inicial();
 4193              		.loc 1 327 0
 4194 0d18 FEFFFFEB 		bl	Sudoku_Pantalla_Inicial
 330:../button.c   ****                                 estado_juego = ESPERANDO_INICIO;
 4195              		.loc 1 330 0
 4196 0d1c 40309FE5 		ldr	r3, .L68
 4197 0d20 0020A0E3 		mov	r2, #0
 4198 0d24 0020C3E5 		strb	r2, [r3, #0]
 331:../button.c   ****                                 int_count = 0;
 4199              		.loc 1 331 0
 4200 0d28 44309FE5 		ldr	r3, .L68+16
 4201 0d2c 0020A0E3 		mov	r2, #0
 4202 0d30 0020C3E5 		strb	r2, [r3, #0]
 332:../button.c   ****                                 pantalla_mostrada = 0;
 4203              		.loc 1 332 0
 4204 0d34 3C309FE5 		ldr	r3, .L68+20
 4205 0d38 0020A0E3 		mov	r2, #0
 4206 0d3c 0020C3E5 		strb	r2, [r3, #0]
 4207              		.loc 1 334 0
 4208 0d40 040000EA 		b	.L26
 4209              	.L65:
 147:../button.c   ****                         break;
 4210              		.loc 1 147 0
 4211 0d44 0000A0E1 		mov	r0, r0	@ nop
 4212 0d48 020000EA 		b	.L26
 4213              	.L66:
 168:../button.c   ****                         break;
 4214              		.loc 1 168 0
 4215 0d4c 0000A0E1 		mov	r0, r0	@ nop
 4216 0d50 000000EA 		b	.L26
 4217              	.L67:
 206:../button.c   ****                         break;
 4218              		.loc 1 206 0
 4219 0d54 0000A0E1 		mov	r0, r0	@ nop
 4220              	.L26:
 335:../button.c   ****         }
 336:../button.c   **** }
 4221              		.loc 1 336 0
 4222 0d58 0CD04BE2 		sub	sp, fp, #12
 4223 0d5c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4224 0d60 1EFF2FE1 		bx	lr
 4225              	.L69:
 4226              		.align	2
 4227              	.L68:
 4228 0d64 00000000 		.word	estado_juego
 4229 0d68 08000000 		.word	tiempo_inicio
 4230 0d6c 00000000 		.word	cuadricula
 4231 0d70 00000000 		.word	celdas_vacias
 4232 0d74 01000000 		.word	int_count
 4233 0d78 06000000 		.word	pantalla_mostrada
 4234 0d7c 0C000000 		.word	tiempo_final
 4235 0d80 02000000 		.word	fila
 4236 0d84 03000000 		.word	columna
 4237 0d88 04000000 		.word	valor
 4238 0d8c 05000000 		.word	valor_previo
 4239              		.cfi_endproc
 4240              	.LFE8:
 4242              		.align	2
 4243              		.global	Eint4567_ISR
 4245              	Eint4567_ISR:
 4246              	.LFB9:
 337:../button.c   **** 
 338:../button.c   **** /* declaración de función que es rutina de servicio de interrupción
 339:../button.c   ****  * https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
 340:../button.c   **** void Eint4567_ISR(void) __attribute__((interrupt("IRQ")));
 341:../button.c   **** 
 342:../button.c   **** /*--- código de funciones ---*/
 343:../button.c   **** void Eint4567_ISR(void)
 344:../button.c   **** {
 4247              		.loc 1 344 0
 4248              		.cfi_startproc
 4249              		@ Interrupt Service Routine.
 4250              		@ args = 0, pretend = 0, frame = 8
 4251              		@ frame_needed = 1, uses_anonymous_args = 0
 4252 0d90 04C02DE5 		str	ip, [sp, #-4]!
 4253 0d94 0DC0A0E1 		mov	ip, sp
 4254              	.LCFI16:
 4255              		.cfi_def_cfa_register 12
 4256 0d98 0FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 4257 0d9c 04B04CE2 		sub	fp, ip, #4
 4258              		.cfi_offset 14, -8
 4259              		.cfi_offset 13, -12
 4260              		.cfi_offset 11, -16
 4261              		.cfi_offset 3, -20
 4262              		.cfi_offset 2, -24
 4263              		.cfi_offset 1, -28
 4264              		.cfi_offset 0, -32
 4265              	.LCFI17:
 4266              		.cfi_def_cfa 11, 4
 4267 0da0 08D04DE2 		sub	sp, sp, #8
 345:../button.c   ****         /* Identificar la interrupción (hay dos pulsadores) */
 346:../button.c   ****         unsigned int pending = rEXTINTPND & 0xF;
 4268              		.loc 1 346 0
 4269 0da4 8C309FE5 		ldr	r3, .L74
 4270 0da8 003093E5 		ldr	r3, [r3, #0]
 4271 0dac 0F3003E2 		and	r3, r3, #15
 4272 0db0 24300BE5 		str	r3, [fp, #-36]
 347:../button.c   ****         uint8_t boton_id = 0;
 4273              		.loc 1 347 0
 4274 0db4 0030A0E3 		mov	r3, #0
 4275 0db8 1D304BE5 		strb	r3, [fp, #-29]
 348:../button.c   **** 
 349:../button.c   ****         if (pending & 0x4)
 4276              		.loc 1 349 0
 4277 0dbc 24301BE5 		ldr	r3, [fp, #-36]
 4278 0dc0 043003E2 		and	r3, r3, #4
 4279 0dc4 000053E3 		cmp	r3, #0
 4280 0dc8 0200000A 		beq	.L71
 350:../button.c   ****         {
 351:../button.c   ****                 boton_id = EVENTO_BOTON_IZQUIERDO;
 4281              		.loc 1 351 0
 4282 0dcc 0430A0E3 		mov	r3, #4
 4283 0dd0 1D304BE5 		strb	r3, [fp, #-29]
 4284 0dd4 050000EA 		b	.L72
 4285              	.L71:
 352:../button.c   ****         }
 353:../button.c   ****         else if (pending & 0x8)
 4286              		.loc 1 353 0
 4287 0dd8 24301BE5 		ldr	r3, [fp, #-36]
 4288 0ddc 083003E2 		and	r3, r3, #8
 4289 0de0 000053E3 		cmp	r3, #0
 4290 0de4 0100000A 		beq	.L72
 354:../button.c   ****         {
 355:../button.c   ****                 boton_id = EVENTO_BOTON_DERECHO;
 4291              		.loc 1 355 0
 4292 0de8 0830A0E3 		mov	r3, #8
 4293 0dec 1D304BE5 		strb	r3, [fp, #-29]
 4294              	.L72:
 356:../button.c   ****         }
 357:../button.c   **** 
 358:../button.c   ****         if (boton_id != 0U)
 4295              		.loc 1 358 0
 4296 0df0 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 4297 0df4 000053E3 		cmp	r3, #0
 4298 0df8 0200000A 		beq	.L73
 359:../button.c   ****         {
 360:../button.c   ****                 /* No registrar la pulsación inicial, solo las confirmadas */
 361:../button.c   **** 
 362:../button.c   ****                 /* Iniciar la máquina de antirrebotes. Si está ocupada, no hacer nada */
 363:../button.c   ****                 timer3_start_antirrebote(boton_id);
 4299              		.loc 1 363 0
 4300 0dfc 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 4301 0e00 0300A0E1 		mov	r0, r3
 4302 0e04 FEFFFFEB 		bl	timer3_start_antirrebote
 4303              	.L73:
 364:../button.c   ****         }
 365:../button.c   **** 
 366:../button.c   ****         /* Finalizar ISR */
 367:../button.c   ****         rEXTINTPND = 0xf;                               // borra los bits en EXTINTPND
 4304              		.loc 1 367 0
 4305 0e08 28309FE5 		ldr	r3, .L74
 4306 0e0c 0F20A0E3 		mov	r2, #15
 4307 0e10 002083E5 		str	r2, [r3, #0]
 368:../button.c   ****         rI_ISPC   |= BIT_EINT4567;              // borra el bit pendiente en INTPND
 4308              		.loc 1 368 0
 4309 0e14 20309FE5 		ldr	r3, .L74+4
 4310 0e18 1C209FE5 		ldr	r2, .L74+4
 4311 0e1c 002092E5 		ldr	r2, [r2, #0]
 4312 0e20 022682E3 		orr	r2, r2, #2097152
 4313 0e24 002083E5 		str	r2, [r3, #0]
 369:../button.c   **** }
 4314              		.loc 1 369 0
 4315 0e28 1CD04BE2 		sub	sp, fp, #28
 4316 0e2c 0F689DE8 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 4317 0e30 04C09DE4 		ldmfd	sp!, {ip}
 4318 0e34 04F05EE2 		subs	pc, lr, #4
 4319              	.L75:
 4320              		.align	2
 4321              	.L74:
 4322 0e38 5400D201 		.word	30539860
 4323 0e3c 2400E001 		.word	31457316
 4324              		.cfi_endproc
 4325              	.LFE9:
 4327              		.align	2
 4328              		.global	Sudoku_Partida_Terminada
 4330              	Sudoku_Partida_Terminada:
 4331              	.LFB10:
 370:../button.c   **** /* Función para consultar si la partida está terminada */
 371:../button.c   **** int Sudoku_Partida_Terminada(void)
 372:../button.c   **** {
 4332              		.loc 1 372 0
 4333              		.cfi_startproc
 4334              		@ Function supports interworking.
 4335              		@ args = 0, pretend = 0, frame = 0
 4336              		@ frame_needed = 1, uses_anonymous_args = 0
 4337 0e40 0DC0A0E1 		mov	ip, sp
 4338              	.LCFI18:
 4339              		.cfi_def_cfa_register 12
 4340 0e44 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4341 0e48 04B04CE2 		sub	fp, ip, #4
 4342              		.cfi_offset 14, -8
 4343              		.cfi_offset 13, -12
 4344              		.cfi_offset 11, -16
 4345              	.LCFI19:
 4346              		.cfi_def_cfa 11, 4
 373:../button.c   **** 	return (estado_juego == PARTIDA_TERMINADA);
 4347              		.loc 1 373 0
 4348 0e4c 20309FE5 		ldr	r3, .L77
 4349 0e50 0030D3E5 		ldrb	r3, [r3, #0]
 4350 0e54 FF3003E2 		and	r3, r3, #255
 4351 0e58 070053E3 		cmp	r3, #7
 4352 0e5c 0030A013 		movne	r3, #0
 4353 0e60 0130A003 		moveq	r3, #1
 374:../button.c   **** }
 4354              		.loc 1 374 0
 4355 0e64 0300A0E1 		mov	r0, r3
 4356 0e68 0CD04BE2 		sub	sp, fp, #12
 4357 0e6c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4358 0e70 1EFF2FE1 		bx	lr
 4359              	.L78:
 4360              		.align	2
 4361              	.L77:
 4362 0e74 00000000 		.word	estado_juego
 4363              		.cfi_endproc
 4364              	.LFE10:
 4366              		.align	2
 4367              		.global	Sudoku_Juego_En_Progreso
 4369              	Sudoku_Juego_En_Progreso:
 4370              	.LFB11:
 375:../button.c   **** 
 376:../button.c   **** /* Función para consultar si el juego está en progreso */
 377:../button.c   **** int Sudoku_Juego_En_Progreso(void)
 378:../button.c   **** {
 4371              		.loc 1 378 0
 4372              		.cfi_startproc
 4373              		@ Function supports interworking.
 4374              		@ args = 0, pretend = 0, frame = 0
 4375              		@ frame_needed = 1, uses_anonymous_args = 0
 4376 0e78 0DC0A0E1 		mov	ip, sp
 4377              	.LCFI20:
 4378              		.cfi_def_cfa_register 12
 4379 0e7c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4380 0e80 04B04CE2 		sub	fp, ip, #4
 4381              		.cfi_offset 14, -8
 4382              		.cfi_offset 13, -12
 4383              		.cfi_offset 11, -16
 4384              	.LCFI21:
 4385              		.cfi_def_cfa 11, 4
 379:../button.c   **** 	return (estado_juego != ESPERANDO_INICIO && estado_juego != PARTIDA_TERMINADA);
 4386              		.loc 1 379 0
 4387 0e84 3C309FE5 		ldr	r3, .L82
 4388 0e88 0030D3E5 		ldrb	r3, [r3, #0]
 4389 0e8c FF3003E2 		and	r3, r3, #255
 4390 0e90 000053E3 		cmp	r3, #0
 4391 0e94 0600000A 		beq	.L80
 4392              		.loc 1 379 0 is_stmt 0 discriminator 1
 4393 0e98 28309FE5 		ldr	r3, .L82
 4394 0e9c 0030D3E5 		ldrb	r3, [r3, #0]
 4395 0ea0 FF3003E2 		and	r3, r3, #255
 4396 0ea4 070053E3 		cmp	r3, #7
 4397 0ea8 0100000A 		beq	.L80
 4398 0eac 0130A0E3 		mov	r3, #1
 4399 0eb0 000000EA 		b	.L81
 4400              	.L80:
 4401              		.loc 1 379 0 discriminator 2
 4402 0eb4 0030A0E3 		mov	r3, #0
 4403              	.L81:
 380:../button.c   **** }
 4404              		.loc 1 380 0 is_stmt 1 discriminator 3
 4405 0eb8 0300A0E1 		mov	r0, r3
 4406 0ebc 0CD04BE2 		sub	sp, fp, #12
 4407 0ec0 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4408 0ec4 1EFF2FE1 		bx	lr
 4409              	.L83:
 4410              		.align	2
 4411              	.L82:
 4412 0ec8 00000000 		.word	estado_juego
 4413              		.cfi_endproc
 4414              	.LFE11:
 4416              		.align	2
 4417              		.global	Sudoku_Obtener_Tiempo_Inicio
 4419              	Sudoku_Obtener_Tiempo_Inicio:
 4420              	.LFB12:
 381:../button.c   **** 
 382:../button.c   **** /* Función para obtener el tiempo de inicio de la partida */
 383:../button.c   **** unsigned int Sudoku_Obtener_Tiempo_Inicio(void)
 384:../button.c   **** {
 4421              		.loc 1 384 0
 4422              		.cfi_startproc
 4423              		@ Function supports interworking.
 4424              		@ args = 0, pretend = 0, frame = 0
 4425              		@ frame_needed = 1, uses_anonymous_args = 0
 4426 0ecc 0DC0A0E1 		mov	ip, sp
 4427              	.LCFI22:
 4428              		.cfi_def_cfa_register 12
 4429 0ed0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4430 0ed4 04B04CE2 		sub	fp, ip, #4
 4431              		.cfi_offset 14, -8
 4432              		.cfi_offset 13, -12
 4433              		.cfi_offset 11, -16
 4434              	.LCFI23:
 4435              		.cfi_def_cfa 11, 4
 385:../button.c   **** 	return tiempo_inicio;
 4436              		.loc 1 385 0
 4437 0ed8 10309FE5 		ldr	r3, .L85
 4438 0edc 003093E5 		ldr	r3, [r3, #0]
 386:../button.c   **** }
 4439              		.loc 1 386 0
 4440 0ee0 0300A0E1 		mov	r0, r3
 4441 0ee4 0CD04BE2 		sub	sp, fp, #12
 4442 0ee8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4443 0eec 1EFF2FE1 		bx	lr
 4444              	.L86:
 4445              		.align	2
 4446              	.L85:
 4447 0ef0 08000000 		.word	tiempo_inicio
 4448              		.cfi_endproc
 4449              	.LFE12:
 4451              		.align	2
 4452              		.global	Eint4567_init
 4454              	Eint4567_init:
 4455              	.LFB13:
 387:../button.c   **** void Eint4567_init(void)
 388:../button.c   **** {
 4456              		.loc 1 388 0
 4457              		.cfi_startproc
 4458              		@ Function supports interworking.
 4459              		@ args = 0, pretend = 0, frame = 0
 4460              		@ frame_needed = 1, uses_anonymous_args = 0
 4461 0ef4 0DC0A0E1 		mov	ip, sp
 4462              	.LCFI24:
 4463              		.cfi_def_cfa_register 12
 4464 0ef8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4465 0efc 04B04CE2 		sub	fp, ip, #4
 4466              		.cfi_offset 14, -8
 4467              		.cfi_offset 13, -12
 4468              		.cfi_offset 11, -16
 4469              	.LCFI25:
 4470              		.cfi_def_cfa 11, 4
 389:../button.c   ****         /* Inicializar el temporizador dedicado a la eliminación de rebotes */
 390:../button.c   ****         timer3_init(boton_confirmado);
 4471              		.loc 1 390 0
 4472 0f00 AC009FE5 		ldr	r0, .L88
 4473 0f04 FEFFFFEB 		bl	timer3_init
 391:../button.c   **** 
 392:../button.c   ****         /* Configuracion del controlador de interrupciones. Estos registros están definidos en 44b
 393:../button.c   ****         rI_ISPC    = 0x3ffffff;         // Borra INTPND escribiendo 1s en I_ISPC
 4474              		.loc 1 393 0
 4475 0f08 A8309FE5 		ldr	r3, .L88+4
 4476 0f0c 3F23E0E3 		mvn	r2, #-67108864
 4477 0f10 002083E5 		str	r2, [r3, #0]
 394:../button.c   ****         rEXTINTPND = 0xf;               // Borra EXTINTPND escribiendo 1s en el propio registro
 4478              		.loc 1 394 0
 4479 0f14 A0309FE5 		ldr	r3, .L88+8
 4480 0f18 0F20A0E3 		mov	r2, #15
 4481 0f1c 002083E5 		str	r2, [r3, #0]
 395:../button.c   ****         rINTMOD    = 0x0;               // Configura las lineas como de tipo IRQ
 4482              		.loc 1 395 0
 4483 0f20 98309FE5 		ldr	r3, .L88+12
 4484 0f24 0020A0E3 		mov	r2, #0
 4485 0f28 002083E5 		str	r2, [r3, #0]
 396:../button.c   ****         rINTCON    = 0x1;               // Habilita int. vectorizadas y la linea IRQ (FIQ no)
 4486              		.loc 1 396 0
 4487 0f2c 1E36A0E3 		mov	r3, #31457280
 4488 0f30 0120A0E3 		mov	r2, #1
 4489 0f34 002083E5 		str	r2, [r3, #0]
 397:../button.c   ****         rINTMSK    &= ~(BIT_EINT4567);  // habilitamos interrupcion linea eint4567 en vector de mas
 4490              		.loc 1 397 0
 4491 0f38 84309FE5 		ldr	r3, .L88+16
 4492 0f3c 80209FE5 		ldr	r2, .L88+16
 4493 0f40 002092E5 		ldr	r2, [r2, #0]
 4494 0f44 0226C2E3 		bic	r2, r2, #2097152
 4495 0f48 002083E5 		str	r2, [r3, #0]
 398:../button.c   **** 
 399:../button.c   ****         /* Establece la rutina de servicio para Eint4567 */
 400:../button.c   ****         pISR_EINT4567 = (int) Eint4567_ISR;
 4496              		.loc 1 400 0
 4497 0f4c 74309FE5 		ldr	r3, .L88+20
 4498 0f50 74209FE5 		ldr	r2, .L88+24
 4499 0f54 002083E5 		str	r2, [r3, #0]
 401:../button.c   **** 
 402:../button.c   ****         /* Configuracion del puerto G */
 403:../button.c   ****         rPCONG  = 0xffff;                       // Establece la funcion de los pines (EINT0-7)
 4500              		.loc 1 403 0
 4501 0f58 70309FE5 		ldr	r3, .L88+28
 4502 0f5c 70209FE5 		ldr	r2, .L88+32
 4503 0f60 002083E5 		str	r2, [r3, #0]
 404:../button.c   ****         rPUPG   = 0x0;                  // Habilita el "pull up" del puerto
 4504              		.loc 1 404 0
 4505 0f64 6C309FE5 		ldr	r3, .L88+36
 4506 0f68 0020A0E3 		mov	r2, #0
 4507 0f6c 002083E5 		str	r2, [r3, #0]
 405:../button.c   ****         rEXTINT = rEXTINT | 0x22222222;   // Configura las lineas de int. como de flanco de bajada
 4508              		.loc 1 405 0
 4509 0f70 64209FE5 		ldr	r2, .L88+40
 4510 0f74 60309FE5 		ldr	r3, .L88+40
 4511 0f78 001093E5 		ldr	r1, [r3, #0]
 4512 0f7c 5C309FE5 		ldr	r3, .L88+44
 4513 0f80 033081E1 		orr	r3, r1, r3
 4514 0f84 003082E5 		str	r3, [r2, #0]
 406:../button.c   **** 
 407:../button.c   ****         /* Por precaucion, se vuelven a borrar los bits de INTPND y EXTINTPND */
 408:../button.c   ****         rEXTINTPND = 0xf;                               // borra los bits en EXTINTPND
 4515              		.loc 1 408 0
 4516 0f88 2C309FE5 		ldr	r3, .L88+8
 4517 0f8c 0F20A0E3 		mov	r2, #15
 4518 0f90 002083E5 		str	r2, [r3, #0]
 409:../button.c   ****         rI_ISPC   |= BIT_EINT4567;              // borra el bit pendiente en INTPND
 4519              		.loc 1 409 0
 4520 0f94 1C309FE5 		ldr	r3, .L88+4
 4521 0f98 18209FE5 		ldr	r2, .L88+4
 4522 0f9c 002092E5 		ldr	r2, [r2, #0]
 4523 0fa0 022682E3 		orr	r2, r2, #2097152
 4524 0fa4 002083E5 		str	r2, [r3, #0]
 410:../button.c   **** }
 4525              		.loc 1 410 0
 4526 0fa8 0CD04BE2 		sub	sp, fp, #12
 4527 0fac 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4528 0fb0 1EFF2FE1 		bx	lr
 4529              	.L89:
 4530              		.align	2
 4531              	.L88:
 4532 0fb4 00000000 		.word	boton_confirmado
 4533 0fb8 2400E001 		.word	31457316
 4534 0fbc 5400D201 		.word	30539860
 4535 0fc0 0800E001 		.word	31457288
 4536 0fc4 0C00E001 		.word	31457292
 4537 0fc8 74FF7F0C 		.word	209715060
 4538 0fcc 00000000 		.word	Eint4567_ISR
 4539 0fd0 4000D201 		.word	30539840
 4540 0fd4 FFFF0000 		.word	65535
 4541 0fd8 4800D201 		.word	30539848
 4542 0fdc 5000D201 		.word	30539856
 4543 0fe0 22222222 		.word	572662306
 4544              		.cfi_endproc
 4545              	.LFE13:
 4547              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 button.c
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:2979   .text:00000000 $a
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:2981   .text:00000000 celda_poner_valor
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3032   .text:00000078 celda_leer_valor
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3067   .text:000000b0 celda_es_candidato
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3108   .text:00000100 celda_es_pista
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3144   .text:0000013c celda_marcar_error
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3180   .text:00000178 celda_limpiar_error
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3215   .bss:00000000 estado_juego
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3216   .bss:00000000 $d
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3217   .bss:00000001 int_count
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3219   .bss:00000002 fila
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3221   .bss:00000003 columna
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3223   .bss:00000004 valor
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3225   .bss:00000005 valor_previo
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3227   .bss:00000006 pantalla_mostrada
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3230   .bss:00000008 tiempo_inicio
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3233   .bss:0000000c tiempo_final
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3238   .text:000001b4 marcar_celdas_en_conflicto
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3509   .text:000004e8 $d
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3514   .text:000004f0 $a
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3516   .text:000004f0 boton_confirmado
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3555   .text:00000548 $d
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:3565   .text:00000568 $a
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4228   .text:00000d64 $d
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4242   .text:00000d90 $a
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4245   .text:00000d90 Eint4567_ISR
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4322   .text:00000e38 $d
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4327   .text:00000e40 $a
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4330   .text:00000e40 Sudoku_Partida_Terminada
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4362   .text:00000e74 $d
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4366   .text:00000e78 $a
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4369   .text:00000e78 Sudoku_Juego_En_Progreso
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4412   .text:00000ec8 $d
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4416   .text:00000ecc $a
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4419   .text:00000ecc Sudoku_Obtener_Tiempo_Inicio
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4447   .text:00000ef0 $d
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4451   .text:00000ef4 $a
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4454   .text:00000ef4 Eint4567_init
C:\Users\jaime\AppData\Local\Temp\ccyXpDcN.s:4532   .text:00000fb4 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
cuadricula
timer2_count
cola_depuracion
candidatos_actualizar_all
Sudoku_Dibujar_Tablero
Sudoku_Actualizar_Tablero_Completo
D8Led_symbol
candidatos_propagar_arm
Sudoku_Pantalla_Final
Sudoku_Pantalla_Inicial
celdas_vacias
timer3_start_antirrebote
timer3_init
