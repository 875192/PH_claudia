   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"button.c"
  21              	.Ltext0:
  22              		.file 1 "../button.c"
 2979              		.align	2
 2981              	celda_poner_valor:
 2982              	.LFB1:
   1:../celda.h    **** 	/* guarda para evitar inclusiones mÃºltiples (include guard) */
   2:../celda.h    **** 	#ifndef CELDA_H
   3:../celda.h    **** 	#define CELDA_H
   4:../celda.h    **** 	
   5:../celda.h    **** 	#include <inttypes.h>
   6:../celda.h    **** 	
   7:../celda.h    **** 	/* Cada celda se codifica en 16 bits
   8:../celda.h    **** 	 * bits [15,7]: los 9 bits mÃ¡s significativos representan el vector de candidatos,
   9:../celda.h    **** 	 * si el bit 7 + valor - 1 estÃ¡ a 0, valor es candidato, 1 en caso contrario
  10:../celda.h    **** 	 * bit 6: no empleado
  11:../celda.h    **** 	 * bit 5: error
  12:../celda.h    **** 	 * bit 4: pista
  13:../celda.h    **** 	 * bits [3,0]: valor de la celda
  14:../celda.h    **** 	 */
  15:../celda.h    **** 	
  16:../celda.h    **** enum { BIT_CANDIDATOS = 7, BIT_NO_USADO = 6, BIT_ERROR = 5, BIT_PISTA = 4 };
  17:../celda.h    **** 	
  18:../celda.h    **** 	typedef uint16_t CELDA;
  19:../celda.h    **** 	
  20:../celda.h    **** 	/* *****************************************************************************
  21:../celda.h    **** 	 * elimina el candidato del valor almacenado en la celda indicada */
  22:../celda.h    **** 	__inline static void
  23:../celda.h    **** 	celda_eliminar_candidato(CELDA *celdaptr, uint8_t valor)
  24:../celda.h    **** 	{
  25:../celda.h    **** 		*celdaptr = *celdaptr | (0x0001 << (BIT_CANDIDATOS + valor - 1));
  26:../celda.h    **** 	}
  27:../celda.h    **** 	
  28:../celda.h    **** 	/* *****************************************************************************
  29:../celda.h    **** 	 * modifica el valor almacenado en la celda indicada */
  30:../celda.h    **** 	__inline static void
  31:../celda.h    **** 	celda_poner_valor(CELDA *celdaptr, uint8_t val)
  32:../celda.h    **** 	{
 2983              		.loc 17 32 0
 2984              		.cfi_startproc
 2985              		@ Function supports interworking.
 2986              		@ args = 0, pretend = 0, frame = 8
 2987              		@ frame_needed = 1, uses_anonymous_args = 0
 2988 0000 0DC0A0E1 		mov	ip, sp
 2989              	.LCFI0:
 2990              		.cfi_def_cfa_register 12
 2991 0004 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 2992 0008 04B04CE2 		sub	fp, ip, #4
 2993              		.cfi_offset 14, -8
 2994              		.cfi_offset 13, -12
 2995              		.cfi_offset 11, -16
 2996              	.LCFI1:
 2997              		.cfi_def_cfa 11, 4
 2998 000c 08D04DE2 		sub	sp, sp, #8
 2999 0010 10000BE5 		str	r0, [fp, #-16]
 3000 0014 0130A0E1 		mov	r3, r1
 3001 0018 11304BE5 		strb	r3, [fp, #-17]
  33:../celda.h    **** 		*celdaptr = (*celdaptr & 0xFFF0) | (val & 0x000F);
 3002              		.loc 17 33 0
 3003 001c 10301BE5 		ldr	r3, [fp, #-16]
 3004 0020 B030D3E1 		ldrh	r3, [r3, #0]
 3005 0024 0338A0E1 		mov	r3, r3, asl #16
 3006 0028 2338A0E1 		mov	r3, r3, lsr #16
 3007 002c 0F30C3E3 		bic	r3, r3, #15
 3008 0030 0338A0E1 		mov	r3, r3, asl #16
 3009 0034 2328A0E1 		mov	r2, r3, lsr #16
 3010 0038 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 3011 003c 0338A0E1 		mov	r3, r3, asl #16
 3012 0040 2338A0E1 		mov	r3, r3, lsr #16
 3013 0044 0F3003E2 		and	r3, r3, #15
 3014 0048 0338A0E1 		mov	r3, r3, asl #16
 3015 004c 2338A0E1 		mov	r3, r3, lsr #16
 3016 0050 033082E1 		orr	r3, r2, r3
 3017 0054 0338A0E1 		mov	r3, r3, asl #16
 3018 0058 2338A0E1 		mov	r3, r3, lsr #16
 3019 005c 0338A0E1 		mov	r3, r3, asl #16
 3020 0060 2328A0E1 		mov	r2, r3, lsr #16
 3021 0064 10301BE5 		ldr	r3, [fp, #-16]
 3022 0068 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  34:../celda.h    **** 	}
 3023              		.loc 17 34 0
 3024 006c 0CD04BE2 		sub	sp, fp, #12
 3025 0070 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3026 0074 1EFF2FE1 		bx	lr
 3027              		.cfi_endproc
 3028              	.LFE1:
 3030              		.align	2
 3032              	celda_leer_valor:
 3033              	.LFB2:
  35:../celda.h    **** 	
  36:../celda.h    **** 	/* *****************************************************************************
  37:../celda.h    **** 	 * extrae el valor almacenado en los 16 bits de una celda */
  38:../celda.h    ****         __inline static uint8_t
  39:../celda.h    ****         celda_leer_valor(CELDA celda)
  40:../celda.h    ****         {
 3034              		.loc 17 40 0
 3035              		.cfi_startproc
 3036              		@ Function supports interworking.
 3037              		@ args = 0, pretend = 0, frame = 8
 3038              		@ frame_needed = 1, uses_anonymous_args = 0
 3039 0078 0DC0A0E1 		mov	ip, sp
 3040              	.LCFI2:
 3041              		.cfi_def_cfa_register 12
 3042 007c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3043 0080 04B04CE2 		sub	fp, ip, #4
 3044              		.cfi_offset 14, -8
 3045              		.cfi_offset 13, -12
 3046              		.cfi_offset 11, -16
 3047              	.LCFI3:
 3048              		.cfi_def_cfa 11, 4
 3049 0084 08D04DE2 		sub	sp, sp, #8
 3050 0088 0030A0E1 		mov	r3, r0
 3051 008c BE304BE1 		strh	r3, [fp, #-14]	@ movhi
  41:../celda.h    ****                 return (celda & 0x000F);
 3052              		.loc 17 41 0
 3053 0090 BE305BE1 		ldrh	r3, [fp, #-14]	@ movhi
 3054 0094 FF3003E2 		and	r3, r3, #255
 3055 0098 0F3003E2 		and	r3, r3, #15
 3056 009c FF3003E2 		and	r3, r3, #255
  42:../celda.h    ****         }
 3057              		.loc 17 42 0
 3058 00a0 0300A0E1 		mov	r0, r3
 3059 00a4 0CD04BE2 		sub	sp, fp, #12
 3060 00a8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3061 00ac 1EFF2FE1 		bx	lr
 3062              		.cfi_endproc
 3063              	.LFE2:
 3065              		.align	2
 3067              	celda_es_candidato:
 3068              	.LFB3:
  43:../celda.h    **** 
  44:../celda.h    ****         /* *****************************************************************************
  45:../celda.h    ****          * comprueba si el valor es candidato en la celda indicada */
  46:../celda.h    ****         __inline static int
  47:../celda.h    ****         celda_es_candidato(CELDA celda, uint8_t valor)
  48:../celda.h    ****         {
 3069              		.loc 17 48 0
 3070              		.cfi_startproc
 3071              		@ Function supports interworking.
 3072              		@ args = 0, pretend = 0, frame = 8
 3073              		@ frame_needed = 1, uses_anonymous_args = 0
 3074 00b0 0DC0A0E1 		mov	ip, sp
 3075              	.LCFI4:
 3076              		.cfi_def_cfa_register 12
 3077 00b4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3078 00b8 04B04CE2 		sub	fp, ip, #4
 3079              		.cfi_offset 14, -8
 3080              		.cfi_offset 13, -12
 3081              		.cfi_offset 11, -16
 3082              	.LCFI5:
 3083              		.cfi_def_cfa 11, 4
 3084 00bc 08D04DE2 		sub	sp, sp, #8
 3085 00c0 0020A0E1 		mov	r2, r0
 3086 00c4 0130A0E1 		mov	r3, r1
 3087 00c8 BE204BE1 		strh	r2, [fp, #-14]	@ movhi
 3088 00cc 0F304BE5 		strb	r3, [fp, #-15]
  49:../celda.h    ****                 return (celda & (0x0001 << (BIT_CANDIDATOS + valor - 1))) == 0;
 3089              		.loc 17 49 0
 3090 00d0 BE205BE1 		ldrh	r2, [fp, #-14]
 3091 00d4 0F305BE5 		ldrb	r3, [fp, #-15]	@ zero_extendqisi2
 3092 00d8 063083E2 		add	r3, r3, #6
 3093 00dc 5233A0E1 		mov	r3, r2, asr r3
 3094 00e0 013003E2 		and	r3, r3, #1
 3095 00e4 000053E3 		cmp	r3, #0
 3096 00e8 0030A013 		movne	r3, #0
 3097 00ec 0130A003 		moveq	r3, #1
  50:../celda.h    ****         }
 3098              		.loc 17 50 0
 3099 00f0 0300A0E1 		mov	r0, r3
 3100 00f4 0CD04BE2 		sub	sp, fp, #12
 3101 00f8 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3102 00fc 1EFF2FE1 		bx	lr
 3103              		.cfi_endproc
 3104              	.LFE3:
 3106              		.align	2
 3108              	celda_es_pista:
 3109              	.LFB4:
  51:../celda.h    **** 
  52:../celda.h    ****         /* *****************************************************************************
  53:../celda.h    ****          * comprueba si la celda es una pista */
  54:../celda.h    ****         __inline static int
  55:../celda.h    ****         celda_es_pista(CELDA celda)
  56:../celda.h    ****         {
 3110              		.loc 17 56 0
 3111              		.cfi_startproc
 3112              		@ Function supports interworking.
 3113              		@ args = 0, pretend = 0, frame = 8
 3114              		@ frame_needed = 1, uses_anonymous_args = 0
 3115 0100 0DC0A0E1 		mov	ip, sp
 3116              	.LCFI6:
 3117              		.cfi_def_cfa_register 12
 3118 0104 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3119 0108 04B04CE2 		sub	fp, ip, #4
 3120              		.cfi_offset 14, -8
 3121              		.cfi_offset 13, -12
 3122              		.cfi_offset 11, -16
 3123              	.LCFI7:
 3124              		.cfi_def_cfa 11, 4
 3125 010c 08D04DE2 		sub	sp, sp, #8
 3126 0110 0030A0E1 		mov	r3, r0
 3127 0114 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
  57:../celda.h    ****                 return (celda & (1 << BIT_PISTA)) != 0;
 3128              		.loc 17 57 0
 3129 0118 BE305BE1 		ldrh	r3, [fp, #-14]
 3130 011c 103003E2 		and	r3, r3, #16
 3131 0120 000053E3 		cmp	r3, #0
 3132 0124 0030A003 		moveq	r3, #0
 3133 0128 0130A013 		movne	r3, #1
  58:../celda.h    ****         }
 3134              		.loc 17 58 0
 3135 012c 0300A0E1 		mov	r0, r3
 3136 0130 0CD04BE2 		sub	sp, fp, #12
 3137 0134 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3138 0138 1EFF2FE1 		bx	lr
 3139              		.cfi_endproc
 3140              	.LFE4:
 3142              		.align	2
 3144              	celda_marcar_error:
 3145              	.LFB5:
  59:../celda.h    **** 
  60:../celda.h    ****         /* *****************************************************************************
  61:../celda.h    ****          * marca o limpia el bit de error de la celda */
  62:../celda.h    ****         __inline static void
  63:../celda.h    ****         celda_marcar_error(CELDA *celdaptr)
  64:../celda.h    ****         {
 3146              		.loc 17 64 0
 3147              		.cfi_startproc
 3148              		@ Function supports interworking.
 3149              		@ args = 0, pretend = 0, frame = 8
 3150              		@ frame_needed = 1, uses_anonymous_args = 0
 3151 013c 0DC0A0E1 		mov	ip, sp
 3152              	.LCFI8:
 3153              		.cfi_def_cfa_register 12
 3154 0140 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3155 0144 04B04CE2 		sub	fp, ip, #4
 3156              		.cfi_offset 14, -8
 3157              		.cfi_offset 13, -12
 3158              		.cfi_offset 11, -16
 3159              	.LCFI9:
 3160              		.cfi_def_cfa 11, 4
 3161 0148 08D04DE2 		sub	sp, sp, #8
 3162 014c 10000BE5 		str	r0, [fp, #-16]
  65:../celda.h    ****                 *celdaptr |= (1 << BIT_ERROR);
 3163              		.loc 17 65 0
 3164 0150 10301BE5 		ldr	r3, [fp, #-16]
 3165 0154 B030D3E1 		ldrh	r3, [r3, #0]
 3166 0158 203083E3 		orr	r3, r3, #32
 3167 015c 0338A0E1 		mov	r3, r3, asl #16
 3168 0160 2328A0E1 		mov	r2, r3, lsr #16
 3169 0164 10301BE5 		ldr	r3, [fp, #-16]
 3170 0168 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  66:../celda.h    ****         }
 3171              		.loc 17 66 0
 3172 016c 0CD04BE2 		sub	sp, fp, #12
 3173 0170 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3174 0174 1EFF2FE1 		bx	lr
 3175              		.cfi_endproc
 3176              	.LFE5:
 3178              		.align	2
 3180              	celda_limpiar_error:
 3181              	.LFB6:
  67:../celda.h    **** 
  68:../celda.h    ****         __inline static void
  69:../celda.h    ****         celda_limpiar_error(CELDA *celdaptr)
  70:../celda.h    ****         {
 3182              		.loc 17 70 0
 3183              		.cfi_startproc
 3184              		@ Function supports interworking.
 3185              		@ args = 0, pretend = 0, frame = 8
 3186              		@ frame_needed = 1, uses_anonymous_args = 0
 3187 0178 0DC0A0E1 		mov	ip, sp
 3188              	.LCFI10:
 3189              		.cfi_def_cfa_register 12
 3190 017c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3191 0180 04B04CE2 		sub	fp, ip, #4
 3192              		.cfi_offset 14, -8
 3193              		.cfi_offset 13, -12
 3194              		.cfi_offset 11, -16
 3195              	.LCFI11:
 3196              		.cfi_def_cfa 11, 4
 3197 0184 08D04DE2 		sub	sp, sp, #8
 3198 0188 10000BE5 		str	r0, [fp, #-16]
  71:../celda.h    ****                 *celdaptr &= ~(1 << BIT_ERROR);
 3199              		.loc 17 71 0
 3200 018c 10301BE5 		ldr	r3, [fp, #-16]
 3201 0190 B030D3E1 		ldrh	r3, [r3, #0]
 3202 0194 2030C3E3 		bic	r3, r3, #32
 3203 0198 0338A0E1 		mov	r3, r3, asl #16
 3204 019c 2328A0E1 		mov	r2, r3, lsr #16
 3205 01a0 10301BE5 		ldr	r3, [fp, #-16]
 3206 01a4 B020C3E1 		strh	r2, [r3, #0]	@ movhi
  72:../celda.h    ****         }
 3207              		.loc 17 72 0
 3208 01a8 0CD04BE2 		sub	sp, fp, #12
 3209 01ac 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3210 01b0 1EFF2FE1 		bx	lr
 3211              		.cfi_endproc
 3212              	.LFE6:
 3214              		.bss
 3215              	estado_juego:
 3216 0000 00       		.space	1
 3217              	int_count:
 3218 0001 00       		.space	1
 3219              	fila:
 3220 0002 00       		.space	1
 3221              	columna:
 3222 0003 00       		.space	1
 3223              	valor:
 3224 0004 00       		.space	1
 3225              	valor_previo:
 3226 0005 00       		.space	1
 3227              	pantalla_mostrada:
 3228 0006 00       		.space	1
 3229 0007 00       		.align	2
 3230              	tiempo_inicio:
 3231 0008 00000000 		.space	4
 3232              		.align	2
 3233              	tiempo_final:
 3234 000c 00000000 		.space	4
 3235              		.text
 3236              		.align	2
 3238              	boton_confirmado:
 3239              	.LFB7:
   1:../button.c   **** /*********************************************************************************************
   2:../button.c   **** * Fichero:      button.c
   3:../button.c   **** * Autor:
   4:../button.c   **** * Descrip:      Funciones de manejo de los pulsadores (EINT6-7)
   5:../button.c   **** * Version:
   6:../button.c   **** *********************************************************************************************/
   7:../button.c   **** 
   8:../button.c   **** /*--- ficheros de cabecera ---*/
   9:../button.c   **** #include "button.h"
  10:../button.c   **** #include "8led.h"
  11:../button.c   **** #include "cola.h"
  12:../button.c   **** #include "eventos.h"
  13:../button.c   **** #include "timer2.h"
  14:../button.c   **** #include "timer3.h"
  15:../button.c   **** #include "44blib.h"
  16:../button.c   **** #include "44b.h"
  17:../button.c   **** #include "def.h"
  18:../button.c   **** #include "sudoku_2025.h"
  19:../button.c   **** #include "lcd.h"
  20:../button.c   **** 
  21:../button.c   **** /*--- Variables del juego Sudoku ---*/
  22:../button.c   **** static volatile EstadoSudoku estado_juego = ESPERANDO_INICIO;
  23:../button.c   **** static volatile uint8_t int_count = 0;
  24:../button.c   **** static volatile uint8_t fila = 0;
  25:../button.c   **** static volatile uint8_t columna = 0;
  26:../button.c   **** static volatile uint8_t valor = 0;
  27:../button.c   **** static volatile uint8_t valor_previo = 0;  /* Para detectar modificación de valor */
  28:../button.c   **** static volatile uint8_t pantalla_mostrada = 0;  /* Flag para mostrar pantalla inicial solo una vez 
  29:../button.c   **** static volatile uint32_t tiempo_inicio = 0;  /* Tiempo de inicio de la partida actual */
  30:../button.c   **** static volatile uint32_t tiempo_final = 0;  /* Tiempo final al terminar la partida */
  31:../button.c   **** 
  32:../button.c   **** /* Declaración externa de la cuadrícula del juego */
  33:../button.c   **** extern CELDA (*cuadricula)[NUM_COLUMNAS];
  34:../button.c   **** extern int celdas_vacias;
  35:../button.c   **** 
  36:../button.c   **** /* Callback para recibir la confirmación de pulsaciones filtradas por el timer3 */
  37:../button.c   **** static void boton_confirmado(uint8_t boton_id) // MODIFICAR FUNCIONES ACTUALIZAR Y PROPAGAR SEGUN L
  38:../button.c   **** {
 3240              		.loc 1 38 0
 3241              		.cfi_startproc
 3242              		@ Function supports interworking.
 3243              		@ args = 0, pretend = 0, frame = 8
 3244              		@ frame_needed = 1, uses_anonymous_args = 0
 3245 01b4 0DC0A0E1 		mov	ip, sp
 3246              	.LCFI12:
 3247              		.cfi_def_cfa_register 12
 3248 01b8 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3249 01bc 04B04CE2 		sub	fp, ip, #4
 3250              		.cfi_offset 14, -8
 3251              		.cfi_offset 13, -12
 3252              		.cfi_offset 11, -16
 3253              	.LCFI13:
 3254              		.cfi_def_cfa 11, 4
 3255 01c0 08D04DE2 		sub	sp, sp, #8
 3256 01c4 0030A0E1 		mov	r3, r0
 3257 01c8 0D304BE5 		strb	r3, [fp, #-13]
  39:../button.c   ****         cola_depuracion(timer2_count(), boton_id, estado_juego);
 3258              		.loc 1 39 0
 3259 01cc FEFFFFEB 		bl	timer2_count
 3260 01d0 0010A0E1 		mov	r1, r0
 3261 01d4 34379FE5 		ldr	r3, .L39
 3262 01d8 0030D3E5 		ldrb	r3, [r3, #0]
 3263 01dc FF3003E2 		and	r3, r3, #255
 3264 01e0 0D205BE5 		ldrb	r2, [fp, #-13]	@ zero_extendqisi2
 3265 01e4 0100A0E1 		mov	r0, r1
 3266 01e8 0210A0E1 		mov	r1, r2
 3267 01ec 0320A0E1 		mov	r2, r3
 3268 01f0 FEFFFFEB 		bl	cola_depuracion
  40:../button.c   ****         
  41:../button.c   ****         switch (estado_juego)
 3269              		.loc 1 41 0
 3270 01f4 14379FE5 		ldr	r3, .L39
 3271 01f8 0030D3E5 		ldrb	r3, [r3, #0]
 3272 01fc FF3003E2 		and	r3, r3, #255
 3273 0200 070053E3 		cmp	r3, #7
 3274 0204 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3275 0208 BD0100EA 		b	.L7
 3276              	.L16:
 3277 020c 2C020000 		.word	.L9
 3278 0210 9C020000 		.word	.L10
 3279 0214 8C030000 		.word	.L11
 3280 0218 4C040000 		.word	.L12
 3281 021c D4040000 		.word	.L13
 3282 0220 74050000 		.word	.L14
 3283 0224 04090000 		.word	.L7
 3284 0228 90080000 		.word	.L15
 3285              	.L9:
  42:../button.c   ****         {
  43:../button.c   ****                 case ESPERANDO_INICIO:
  44:../button.c   ****                         /* Cualquier botón inicia el juego */
  45:../button.c   ****                         /* Guardar tiempo de inicio para reiniciar el contador */
  46:../button.c   ****                         tiempo_inicio = timer2_count();
 3286              		.loc 1 46 0
 3287 022c FEFFFFEB 		bl	timer2_count
 3288 0230 0020A0E1 		mov	r2, r0
 3289 0234 D8369FE5 		ldr	r3, .L39+4
 3290 0238 002083E5 		str	r2, [r3, #0]
  47:../button.c   ****                         
  48:../button.c   ****                         /* Calcular candidatos por primera vez */
  49:../button.c   ****                         celdas_vacias = candidatos_actualizar_all(cuadricula);
 3291              		.loc 1 49 0
 3292 023c D4369FE5 		ldr	r3, .L39+8
 3293 0240 003093E5 		ldr	r3, [r3, #0]
 3294 0244 0300A0E1 		mov	r0, r3
 3295 0248 FEFFFFEB 		bl	candidatos_actualizar_all
 3296 024c 0020A0E1 		mov	r2, r0
 3297 0250 C4369FE5 		ldr	r3, .L39+12
 3298 0254 002083E5 		str	r2, [r3, #0]
  50:../button.c   ****                         
  51:../button.c   ****                         /* Dibujar el tablero del juego */
  52:../button.c   ****                         Sudoku_Dibujar_Tablero();
 3299              		.loc 1 52 0
 3300 0258 FEFFFFEB 		bl	Sudoku_Dibujar_Tablero
  53:../button.c   ****                         
  54:../button.c   ****                         /* Actualizar con los valores de la cuadrícula */
  55:../button.c   ****                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3301              		.loc 1 55 0
 3302 025c B4369FE5 		ldr	r3, .L39+8
 3303 0260 003093E5 		ldr	r3, [r3, #0]
 3304 0264 0300A0E1 		mov	r0, r3
 3305 0268 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
  56:../button.c   ****                         
  57:../button.c   ****                         /* Pasar a introducir fila */
  58:../button.c   ****                         estado_juego = INTRODUCIR_FILA;
 3306              		.loc 1 58 0
 3307 026c 9C369FE5 		ldr	r3, .L39
 3308 0270 0120A0E3 		mov	r2, #1
 3309 0274 0020C3E5 		strb	r2, [r3, #0]
  59:../button.c   ****                         int_count = 9;  /* Iniciar en 9 para que al incrementar vaya a 0 */
 3310              		.loc 1 59 0
 3311 0278 A0369FE5 		ldr	r3, .L39+16
 3312 027c 0920A0E3 		mov	r2, #9
 3313 0280 0020C3E5 		strb	r2, [r3, #0]
  60:../button.c   ****                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 3314              		.loc 1 60 0
 3315 0284 0F00A0E3 		mov	r0, #15
 3316 0288 FEFFFFEB 		bl	D8Led_symbol
  61:../button.c   ****                         pantalla_mostrada = 0;  /* Resetear flag para próxima partida */
 3317              		.loc 1 61 0
 3318 028c 90369FE5 		ldr	r3, .L39+20
 3319 0290 0020A0E3 		mov	r2, #0
 3320 0294 0020C3E5 		strb	r2, [r3, #0]
  62:../button.c   ****                         break;
 3321              		.loc 1 62 0
 3322 0298 990100EA 		b	.L7
 3323              	.L10:
  63:../button.c   ****                 
  64:../button.c   ****                 case INTRODUCIR_FILA:
  65:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3324              		.loc 1 65 0
 3325 029c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3326 02a0 080053E3 		cmp	r3, #8
 3327 02a4 1500001A 		bne	.L17
  66:../button.c   ****                         {
  67:../button.c   ****                                 /* Incrementar fila (ciclo: 0 → 1 → 2 → ... → 9 → 0) */
  68:../button.c   ****                                 int_count++;
 3328              		.loc 1 68 0
 3329 02a8 70369FE5 		ldr	r3, .L39+16
 3330 02ac 0030D3E5 		ldrb	r3, [r3, #0]
 3331 02b0 FF3003E2 		and	r3, r3, #255
 3332 02b4 013083E2 		add	r3, r3, #1
 3333 02b8 FF2003E2 		and	r2, r3, #255
 3334 02bc 5C369FE5 		ldr	r3, .L39+16
 3335 02c0 0020C3E5 		strb	r2, [r3, #0]
  69:../button.c   ****                                 if (int_count > 9)
 3336              		.loc 1 69 0
 3337 02c4 54369FE5 		ldr	r3, .L39+16
 3338 02c8 0030D3E5 		ldrb	r3, [r3, #0]
 3339 02cc FF3003E2 		and	r3, r3, #255
 3340 02d0 090053E3 		cmp	r3, #9
 3341 02d4 0200009A 		bls	.L18
  70:../button.c   ****                                 {
  71:../button.c   ****                                         int_count = 0;  /* Volver a 0 */
 3342              		.loc 1 71 0
 3343 02d8 40369FE5 		ldr	r3, .L39+16
 3344 02dc 0020A0E3 		mov	r2, #0
 3345 02e0 0020C3E5 		strb	r2, [r3, #0]
 3346              	.L18:
  72:../button.c   ****                                 }
  73:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3347              		.loc 1 73 0
 3348 02e4 34369FE5 		ldr	r3, .L39+16
 3349 02e8 0030D3E5 		ldrb	r3, [r3, #0]
 3350 02ec FF3003E2 		and	r3, r3, #255
 3351 02f0 0F3003E2 		and	r3, r3, #15
 3352 02f4 0300A0E1 		mov	r0, r3
 3353 02f8 FEFFFFEB 		bl	D8Led_symbol
  74:../button.c   ****                         }
  75:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
  76:../button.c   ****                         {
  77:../button.c   ****                                 /* Verificar si se eligió fila 0 (terminar partida) */
  78:../button.c   ****                                 if (int_count == 0)
  79:../button.c   ****                                 {
  80:../button.c   ****                                         /* Fila 0: terminar la partida */
  81:../button.c   ****                                         /* Guardar tiempo transcurrido desde el inicio de esta part
  82:../button.c   ****                                         tiempo_final = timer2_count() - tiempo_inicio;
  83:../button.c   ****                                         estado_juego = PARTIDA_TERMINADA;
  84:../button.c   ****                                         /* La pantalla final se mostrará en este estado */
  85:../button.c   ****                                 }
  86:../button.c   ****                                 else
  87:../button.c   ****                                 {
  88:../button.c   ****                                         /* Confirmar fila y pasar a introducir columna */
  89:../button.c   ****                                         fila = int_count - 1;  /* Convertir a índice 0-8 */
  90:../button.c   ****                                         estado_juego = INTRODUCIR_COLUMNA;
  91:../button.c   ****                                         int_count = 0;
  92:../button.c   ****                                         D8Led_symbol(12);  /* Mostrar 'C' de Columna (índice 12 en
  93:../button.c   ****                                 }
  94:../button.c   ****                         }
  95:../button.c   ****                         break;
 3354              		.loc 1 95 0
 3355 02fc 800100EA 		b	.L7
 3356              	.L17:
  75:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3357              		.loc 1 75 0
 3358 0300 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3359 0304 040053E3 		cmp	r3, #4
 3360 0308 7801001A 		bne	.L36
  78:../button.c   ****                                 if (int_count == 0)
 3361              		.loc 1 78 0
 3362 030c 0C369FE5 		ldr	r3, .L39+16
 3363 0310 0030D3E5 		ldrb	r3, [r3, #0]
 3364 0314 FF3003E2 		and	r3, r3, #255
 3365 0318 000053E3 		cmp	r3, #0
 3366 031c 0A00001A 		bne	.L20
  82:../button.c   ****                                         tiempo_final = timer2_count() - tiempo_inicio;
 3367              		.loc 1 82 0
 3368 0320 FEFFFFEB 		bl	timer2_count
 3369 0324 0020A0E1 		mov	r2, r0
 3370 0328 E4359FE5 		ldr	r3, .L39+4
 3371 032c 003093E5 		ldr	r3, [r3, #0]
 3372 0330 022063E0 		rsb	r2, r3, r2
 3373 0334 EC359FE5 		ldr	r3, .L39+24
 3374 0338 002083E5 		str	r2, [r3, #0]
  83:../button.c   ****                                         estado_juego = PARTIDA_TERMINADA;
 3375              		.loc 1 83 0
 3376 033c CC359FE5 		ldr	r3, .L39
 3377 0340 0720A0E3 		mov	r2, #7
 3378 0344 0020C3E5 		strb	r2, [r3, #0]
 3379              		.loc 1 95 0
 3380 0348 6D0100EA 		b	.L7
 3381              	.L20:
  89:../button.c   ****                                         fila = int_count - 1;  /* Convertir a índice 0-8 */
 3382              		.loc 1 89 0
 3383 034c CC359FE5 		ldr	r3, .L39+16
 3384 0350 0030D3E5 		ldrb	r3, [r3, #0]
 3385 0354 FF3003E2 		and	r3, r3, #255
 3386 0358 013043E2 		sub	r3, r3, #1
 3387 035c FF2003E2 		and	r2, r3, #255
 3388 0360 C4359FE5 		ldr	r3, .L39+28
 3389 0364 0020C3E5 		strb	r2, [r3, #0]
  90:../button.c   ****                                         estado_juego = INTRODUCIR_COLUMNA;
 3390              		.loc 1 90 0
 3391 0368 A0359FE5 		ldr	r3, .L39
 3392 036c 0220A0E3 		mov	r2, #2
 3393 0370 0020C3E5 		strb	r2, [r3, #0]
  91:../button.c   ****                                         int_count = 0;
 3394              		.loc 1 91 0
 3395 0374 A4359FE5 		ldr	r3, .L39+16
 3396 0378 0020A0E3 		mov	r2, #0
 3397 037c 0020C3E5 		strb	r2, [r3, #0]
  92:../button.c   ****                                         D8Led_symbol(12);  /* Mostrar 'C' de Columna (índice 12 en
 3398              		.loc 1 92 0
 3399 0380 0C00A0E3 		mov	r0, #12
 3400 0384 FEFFFFEB 		bl	D8Led_symbol
 3401              		.loc 1 95 0
 3402 0388 5D0100EA 		b	.L7
 3403              	.L11:
  96:../button.c   ****                 
  97:../button.c   ****                 case INTRODUCIR_COLUMNA:
  98:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3404              		.loc 1 98 0
 3405 038c 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3406 0390 080053E3 		cmp	r3, #8
 3407 0394 1500001A 		bne	.L21
  99:../button.c   ****                         {
 100:../button.c   ****                                 /* Incrementar columna */
 101:../button.c   ****                                 int_count++;
 3408              		.loc 1 101 0
 3409 0398 80359FE5 		ldr	r3, .L39+16
 3410 039c 0030D3E5 		ldrb	r3, [r3, #0]
 3411 03a0 FF3003E2 		and	r3, r3, #255
 3412 03a4 013083E2 		add	r3, r3, #1
 3413 03a8 FF2003E2 		and	r2, r3, #255
 3414 03ac 6C359FE5 		ldr	r3, .L39+16
 3415 03b0 0020C3E5 		strb	r2, [r3, #0]
 102:../button.c   ****                                 if (int_count > 9)
 3416              		.loc 1 102 0
 3417 03b4 64359FE5 		ldr	r3, .L39+16
 3418 03b8 0030D3E5 		ldrb	r3, [r3, #0]
 3419 03bc FF3003E2 		and	r3, r3, #255
 3420 03c0 090053E3 		cmp	r3, #9
 3421 03c4 0200009A 		bls	.L22
 103:../button.c   ****                                 {
 104:../button.c   ****                                         int_count = 1;
 3422              		.loc 1 104 0
 3423 03c8 50359FE5 		ldr	r3, .L39+16
 3424 03cc 0120A0E3 		mov	r2, #1
 3425 03d0 0020C3E5 		strb	r2, [r3, #0]
 3426              	.L22:
 105:../button.c   ****                                 }
 106:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3427              		.loc 1 106 0
 3428 03d4 44359FE5 		ldr	r3, .L39+16
 3429 03d8 0030D3E5 		ldrb	r3, [r3, #0]
 3430 03dc FF3003E2 		and	r3, r3, #255
 3431 03e0 0F3003E2 		and	r3, r3, #15
 3432 03e4 0300A0E1 		mov	r0, r3
 3433 03e8 FEFFFFEB 		bl	D8Led_symbol
 107:../button.c   ****                         }
 108:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 109:../button.c   ****                         {
 110:../button.c   ****                                 /* Confirmar columna y pasar a introducir valor */
 111:../button.c   ****                                 columna = int_count - 1;  /* Convertir a índice 0-8 */
 112:../button.c   ****                                 estado_juego = VERIFICAR_CELDA;
 113:../button.c   ****                                 int_count = 0;
 114:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 115:../button.c   ****                         }
 116:../button.c   ****                         break;
 3434              		.loc 1 116 0
 3435 03ec 440100EA 		b	.L7
 3436              	.L21:
 108:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3437              		.loc 1 108 0
 3438 03f0 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3439 03f4 040053E3 		cmp	r3, #4
 3440 03f8 3E01001A 		bne	.L37
 111:../button.c   ****                                 columna = int_count - 1;  /* Convertir a índice 0-8 */
 3441              		.loc 1 111 0
 3442 03fc 1C359FE5 		ldr	r3, .L39+16
 3443 0400 0030D3E5 		ldrb	r3, [r3, #0]
 3444 0404 FF3003E2 		and	r3, r3, #255
 3445 0408 013043E2 		sub	r3, r3, #1
 3446 040c FF2003E2 		and	r2, r3, #255
 3447 0410 18359FE5 		ldr	r3, .L39+32
 3448 0414 0020C3E5 		strb	r2, [r3, #0]
 112:../button.c   ****                                 estado_juego = VERIFICAR_CELDA;
 3449              		.loc 1 112 0
 3450 0418 F0349FE5 		ldr	r3, .L39
 3451 041c 0320A0E3 		mov	r2, #3
 3452 0420 0020C3E5 		strb	r2, [r3, #0]
 113:../button.c   ****                                 int_count = 0;
 3453              		.loc 1 113 0
 3454 0424 F4349FE5 		ldr	r3, .L39+16
 3455 0428 0020A0E3 		mov	r2, #0
 3456 042c 0020C3E5 		strb	r2, [r3, #0]
 114:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3457              		.loc 1 114 0
 3458 0430 E8349FE5 		ldr	r3, .L39+16
 3459 0434 0030D3E5 		ldrb	r3, [r3, #0]
 3460 0438 FF3003E2 		and	r3, r3, #255
 3461 043c 0F3003E2 		and	r3, r3, #15
 3462 0440 0300A0E1 		mov	r0, r3
 3463 0444 FEFFFFEB 		bl	D8Led_symbol
 3464              		.loc 1 116 0
 3465 0448 2D0100EA 		b	.L7
 3466              	.L12:
 117:../button.c   ****                 
 118:../button.c   ****                 case VERIFICAR_CELDA:
 119:../button.c   ****                         /* Primero se verifica si la celda[fila][columna] no es una pista */
 120:../button.c   ****                         if (celda_es_pista(cuadricula[fila][columna]))
 3467              		.loc 1 120 0
 3468 044c C4349FE5 		ldr	r3, .L39+8
 3469 0450 002093E5 		ldr	r2, [r3, #0]
 3470 0454 D0349FE5 		ldr	r3, .L39+28
 3471 0458 0030D3E5 		ldrb	r3, [r3, #0]
 3472 045c FF3003E2 		and	r3, r3, #255
 3473 0460 8332A0E1 		mov	r3, r3, asl #5
 3474 0464 032082E0 		add	r2, r2, r3
 3475 0468 C0349FE5 		ldr	r3, .L39+32
 3476 046c 0030D3E5 		ldrb	r3, [r3, #0]
 3477 0470 FF3003E2 		and	r3, r3, #255
 3478 0474 8330A0E1 		mov	r3, r3, asl #1
 3479 0478 033082E0 		add	r3, r2, r3
 3480 047c B030D3E1 		ldrh	r3, [r3, #0]
 3481 0480 0300A0E1 		mov	r0, r3
 3482 0484 1DFFFFEB 		bl	celda_es_pista
 3483 0488 0030A0E1 		mov	r3, r0
 3484 048c 000053E3 		cmp	r3, #0
 3485 0490 0800000A 		beq	.L24
 121:../button.c   ****                         {
 122:../button.c   ****                                 // Se vuelve al estado INTRODUCIR_FILA
 123:../button.c   ****                                 estado_juego = INTRODUCIR_FILA;
 3486              		.loc 1 123 0
 3487 0494 74349FE5 		ldr	r3, .L39
 3488 0498 0120A0E3 		mov	r2, #1
 3489 049c 0020C3E5 		strb	r2, [r3, #0]
 124:../button.c   ****                                 int_count = 0;
 3490              		.loc 1 124 0
 3491 04a0 78349FE5 		ldr	r3, .L39+16
 3492 04a4 0020A0E3 		mov	r2, #0
 3493 04a8 0020C3E5 		strb	r2, [r3, #0]
 125:../button.c   ****                                 D8Led_symbol(15);  /* Mostrar 'F' de Fila (índice 15 en el array S
 3494              		.loc 1 125 0
 3495 04ac 0F00A0E3 		mov	r0, #15
 3496 04b0 FEFFFFEB 		bl	D8Led_symbol
 126:../button.c   ****                         } 
 127:../button.c   ****                         else
 128:../button.c   ****                         {
 129:../button.c   ****                                 // Si no es pista, se pasa a INTRODUCIR_VALOR
 130:../button.c   ****                                 estado_juego = INTRODUCIR_VALOR;
 131:../button.c   ****                                 int_count = 0;
 132:../button.c   ****                         }
 133:../button.c   ****                         break;
 3497              		.loc 1 133 0
 3498 04b4 120100EA 		b	.L7
 3499              	.L24:
 130:../button.c   ****                                 estado_juego = INTRODUCIR_VALOR;
 3500              		.loc 1 130 0
 3501 04b8 50349FE5 		ldr	r3, .L39
 3502 04bc 0420A0E3 		mov	r2, #4
 3503 04c0 0020C3E5 		strb	r2, [r3, #0]
 131:../button.c   ****                                 int_count = 0;
 3504              		.loc 1 131 0
 3505 04c4 54349FE5 		ldr	r3, .L39+16
 3506 04c8 0020A0E3 		mov	r2, #0
 3507 04cc 0020C3E5 		strb	r2, [r3, #0]
 3508              		.loc 1 133 0
 3509 04d0 0B0100EA 		b	.L7
 3510              	.L13:
 134:../button.c   ****                 
 135:../button.c   ****                 case INTRODUCIR_VALOR:
 136:../button.c   ****                         if (boton_id == EVENTO_BOTON_DERECHO)
 3511              		.loc 1 136 0
 3512 04d4 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3513 04d8 080053E3 		cmp	r3, #8
 3514 04dc 1500001A 		bne	.L26
 137:../button.c   ****                         {
 138:../button.c   ****                                 /* Incrementar valor */
 139:../button.c   ****                                 int_count++;
 3515              		.loc 1 139 0
 3516 04e0 38349FE5 		ldr	r3, .L39+16
 3517 04e4 0030D3E5 		ldrb	r3, [r3, #0]
 3518 04e8 FF3003E2 		and	r3, r3, #255
 3519 04ec 013083E2 		add	r3, r3, #1
 3520 04f0 FF2003E2 		and	r2, r3, #255
 3521 04f4 24349FE5 		ldr	r3, .L39+16
 3522 04f8 0020C3E5 		strb	r2, [r3, #0]
 140:../button.c   ****                                 if (int_count > 9)
 3523              		.loc 1 140 0
 3524 04fc 1C349FE5 		ldr	r3, .L39+16
 3525 0500 0030D3E5 		ldrb	r3, [r3, #0]
 3526 0504 FF3003E2 		and	r3, r3, #255
 3527 0508 090053E3 		cmp	r3, #9
 3528 050c 0200009A 		bls	.L27
 141:../button.c   ****                                 {
 142:../button.c   ****                                         int_count = 0;
 3529              		.loc 1 142 0
 3530 0510 08349FE5 		ldr	r3, .L39+16
 3531 0514 0020A0E3 		mov	r2, #0
 3532 0518 0020C3E5 		strb	r2, [r3, #0]
 3533              	.L27:
 143:../button.c   ****                                 }
 144:../button.c   ****                                 D8Led_symbol(int_count & 0x000f);
 3534              		.loc 1 144 0
 3535 051c FC339FE5 		ldr	r3, .L39+16
 3536 0520 0030D3E5 		ldrb	r3, [r3, #0]
 3537 0524 FF3003E2 		and	r3, r3, #255
 3538 0528 0F3003E2 		and	r3, r3, #15
 3539 052c 0300A0E1 		mov	r0, r3
 3540 0530 FEFFFFEB 		bl	D8Led_symbol
 145:../button.c   ****                         }
 146:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 147:../button.c   ****                         {
 148:../button.c   ****                                 /* Confirmar valor e intentar escribir en la celda */
 149:../button.c   ****                                 valor = int_count;  /* Valor a escribir (0-9) */
 150:../button.c   ****                                 
 151:../button.c   ****                                 estado_juego = VERIFICAR_VALOR;
 152:../button.c   ****                                 int_count = 0;
 153:../button.c   ****                         }
 154:../button.c   ****                         break;
 3541              		.loc 1 154 0
 3542 0534 F20000EA 		b	.L7
 3543              	.L26:
 146:../button.c   ****                         else if (boton_id == EVENTO_BOTON_IZQUIERDO)
 3544              		.loc 1 146 0
 3545 0538 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 3546 053c 040053E3 		cmp	r3, #4
 3547 0540 EE00001A 		bne	.L38
 149:../button.c   ****                                 valor = int_count;  /* Valor a escribir (0-9) */
 3548              		.loc 1 149 0
 3549 0544 D4339FE5 		ldr	r3, .L39+16
 3550 0548 0030D3E5 		ldrb	r3, [r3, #0]
 3551 054c FF2003E2 		and	r2, r3, #255
 3552 0550 DC339FE5 		ldr	r3, .L39+36
 3553 0554 0020C3E5 		strb	r2, [r3, #0]
 151:../button.c   ****                                 estado_juego = VERIFICAR_VALOR;
 3554              		.loc 1 151 0
 3555 0558 B0339FE5 		ldr	r3, .L39
 3556 055c 0520A0E3 		mov	r2, #5
 3557 0560 0020C3E5 		strb	r2, [r3, #0]
 152:../button.c   ****                                 int_count = 0;
 3558              		.loc 1 152 0
 3559 0564 B4339FE5 		ldr	r3, .L39+16
 3560 0568 0020A0E3 		mov	r2, #0
 3561 056c 0020C3E5 		strb	r2, [r3, #0]
 3562              		.loc 1 154 0
 3563 0570 E30000EA 		b	.L7
 3564              	.L14:
 155:../button.c   ****                 
 156:../button.c   ****                 case VERIFICAR_VALOR:
 157:../button.c   ****                         /* Guardar valor previo de la celda */
 158:../button.c   ****                         valor_previo = celda_leer_valor(cuadricula[fila][columna]);
 3565              		.loc 1 158 0
 3566 0574 9C339FE5 		ldr	r3, .L39+8
 3567 0578 002093E5 		ldr	r2, [r3, #0]
 3568 057c A8339FE5 		ldr	r3, .L39+28
 3569 0580 0030D3E5 		ldrb	r3, [r3, #0]
 3570 0584 FF3003E2 		and	r3, r3, #255
 3571 0588 8332A0E1 		mov	r3, r3, asl #5
 3572 058c 032082E0 		add	r2, r2, r3
 3573 0590 98339FE5 		ldr	r3, .L39+32
 3574 0594 0030D3E5 		ldrb	r3, [r3, #0]
 3575 0598 FF3003E2 		and	r3, r3, #255
 3576 059c 8330A0E1 		mov	r3, r3, asl #1
 3577 05a0 033082E0 		add	r3, r2, r3
 3578 05a4 B030D3E1 		ldrh	r3, [r3, #0]
 3579 05a8 0300A0E1 		mov	r0, r3
 3580 05ac B1FEFFEB 		bl	celda_leer_valor
 3581 05b0 0030A0E1 		mov	r3, r0
 3582 05b4 0320A0E1 		mov	r2, r3
 3583 05b8 78339FE5 		ldr	r3, .L39+40
 3584 05bc 0020C3E5 		strb	r2, [r3, #0]
 159:../button.c   ****                         
 160:../button.c   ****                         if (valor == 0)
 3585              		.loc 1 160 0
 3586 05c0 6C339FE5 		ldr	r3, .L39+36
 3587 05c4 0030D3E5 		ldrb	r3, [r3, #0]
 3588 05c8 FF3003E2 		and	r3, r3, #255
 3589 05cc 000053E3 		cmp	r3, #0
 3590 05d0 3200001A 		bne	.L29
 161:../button.c   ****                         {
 162:../button.c   ****                                 /* Valor 0 = borrar -> pasar a BORRAR_VALOR */
 163:../button.c   ****                                 /* Borrar el valor de la celda */
 164:../button.c   ****                                 celda_limpiar_error(&cuadricula[fila][columna]);
 3591              		.loc 1 164 0
 3592 05d4 3C339FE5 		ldr	r3, .L39+8
 3593 05d8 003093E5 		ldr	r3, [r3, #0]
 3594 05dc 0320A0E1 		mov	r2, r3
 3595 05e0 44339FE5 		ldr	r3, .L39+28
 3596 05e4 0030D3E5 		ldrb	r3, [r3, #0]
 3597 05e8 FF3003E2 		and	r3, r3, #255
 3598 05ec 0312A0E1 		mov	r1, r3, asl #4
 3599 05f0 38339FE5 		ldr	r3, .L39+32
 3600 05f4 0030D3E5 		ldrb	r3, [r3, #0]
 3601 05f8 FF3003E2 		and	r3, r3, #255
 3602 05fc 033081E0 		add	r3, r1, r3
 3603 0600 8330A0E1 		mov	r3, r3, asl #1
 3604 0604 033082E0 		add	r3, r2, r3
 3605 0608 0300A0E1 		mov	r0, r3
 3606 060c D9FEFFEB 		bl	celda_limpiar_error
 165:../button.c   ****                                 celda_poner_valor(&cuadricula[fila][columna], 0);
 3607              		.loc 1 165 0
 3608 0610 00339FE5 		ldr	r3, .L39+8
 3609 0614 003093E5 		ldr	r3, [r3, #0]
 3610 0618 0320A0E1 		mov	r2, r3
 3611 061c 08339FE5 		ldr	r3, .L39+28
 3612 0620 0030D3E5 		ldrb	r3, [r3, #0]
 3613 0624 FF3003E2 		and	r3, r3, #255
 3614 0628 0312A0E1 		mov	r1, r3, asl #4
 3615 062c FC329FE5 		ldr	r3, .L39+32
 3616 0630 0030D3E5 		ldrb	r3, [r3, #0]
 3617 0634 FF3003E2 		and	r3, r3, #255
 3618 0638 033081E0 		add	r3, r1, r3
 3619 063c 8330A0E1 		mov	r3, r3, asl #1
 3620 0640 033082E0 		add	r3, r2, r3
 3621 0644 0300A0E1 		mov	r0, r3
 3622 0648 0010A0E3 		mov	r1, #0
 3623 064c 6BFEFFEB 		bl	celda_poner_valor
 166:../button.c   ****                                 
 167:../button.c   ****                                 /* Al borrar un valor, hay que recalcular todos los candidatos */
 168:../button.c   ****                                 celdas_vacias = candidatos_actualizar_all(cuadricula);
 3624              		.loc 1 168 0
 3625 0650 C0329FE5 		ldr	r3, .L39+8
 3626 0654 003093E5 		ldr	r3, [r3, #0]
 3627 0658 0300A0E1 		mov	r0, r3
 3628 065c FEFFFFEB 		bl	candidatos_actualizar_all
 3629 0660 0020A0E1 		mov	r2, r0
 3630 0664 B0329FE5 		ldr	r3, .L39+12
 3631 0668 002083E5 		str	r2, [r3, #0]
 169:../button.c   ****                                 
 170:../button.c   ****                                 /* Actualizar la visualización del tablero */
 171:../button.c   ****                                 Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3632              		.loc 1 171 0
 3633 066c A4329FE5 		ldr	r3, .L39+8
 3634 0670 003093E5 		ldr	r3, [r3, #0]
 3635 0674 0300A0E1 		mov	r0, r3
 3636 0678 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 172:../button.c   ****                                 
 173:../button.c   ****                                 /* Volver a introducir fila */
 174:../button.c   ****                                 estado_juego = INTRODUCIR_FILA;
 3637              		.loc 1 174 0
 3638 067c 8C329FE5 		ldr	r3, .L39
 3639 0680 0120A0E3 		mov	r2, #1
 3640 0684 0020C3E5 		strb	r2, [r3, #0]
 175:../button.c   ****                                 int_count = 9;  /* Iniciar en 9 para que al incrementar vaya a 0 */
 3641              		.loc 1 175 0
 3642 0688 90329FE5 		ldr	r3, .L39+16
 3643 068c 0920A0E3 		mov	r2, #9
 3644 0690 0020C3E5 		strb	r2, [r3, #0]
 176:../button.c   ****                                 D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 3645              		.loc 1 176 0
 3646 0694 0F00A0E3 		mov	r0, #15
 3647 0698 FEFFFFEB 		bl	D8Led_symbol
 177:../button.c   ****                                 break;
 3648              		.loc 1 177 0
 3649 069c 980000EA 		b	.L7
 3650              	.L29:
 178:../button.c   ****                         }
 179:../button.c   ****                         else
 180:../button.c   ****                         {
 181:../button.c   ****                                 /* Verificar si el valor es candidato */
 182:../button.c   ****                                 if (celda_es_candidato(cuadricula[fila][columna], valor))
 3651              		.loc 1 182 0
 3652 06a0 70329FE5 		ldr	r3, .L39+8
 3653 06a4 002093E5 		ldr	r2, [r3, #0]
 3654 06a8 7C329FE5 		ldr	r3, .L39+28
 3655 06ac 0030D3E5 		ldrb	r3, [r3, #0]
 3656 06b0 FF3003E2 		and	r3, r3, #255
 3657 06b4 8332A0E1 		mov	r3, r3, asl #5
 3658 06b8 032082E0 		add	r2, r2, r3
 3659 06bc 6C329FE5 		ldr	r3, .L39+32
 3660 06c0 0030D3E5 		ldrb	r3, [r3, #0]
 3661 06c4 FF3003E2 		and	r3, r3, #255
 3662 06c8 8330A0E1 		mov	r3, r3, asl #1
 3663 06cc 033082E0 		add	r3, r2, r3
 3664 06d0 B020D3E1 		ldrh	r2, [r3, #0]
 3665 06d4 58329FE5 		ldr	r3, .L39+36
 3666 06d8 0030D3E5 		ldrb	r3, [r3, #0]
 3667 06dc FF3003E2 		and	r3, r3, #255
 3668 06e0 0200A0E1 		mov	r0, r2
 3669 06e4 0310A0E1 		mov	r1, r3
 3670 06e8 70FEFFEB 		bl	celda_es_candidato
 3671 06ec 0030A0E1 		mov	r3, r0
 3672 06f0 000053E3 		cmp	r3, #0
 3673 06f4 4700000A 		beq	.L30
 183:../button.c   ****                                 {
 184:../button.c   ****                                         /* Es candidato: escribir el valor en la celda */
 185:../button.c   ****                                         celda_limpiar_error(&cuadricula[fila][columna]);
 3674              		.loc 1 185 0
 3675 06f8 18329FE5 		ldr	r3, .L39+8
 3676 06fc 003093E5 		ldr	r3, [r3, #0]
 3677 0700 0320A0E1 		mov	r2, r3
 3678 0704 20329FE5 		ldr	r3, .L39+28
 3679 0708 0030D3E5 		ldrb	r3, [r3, #0]
 3680 070c FF3003E2 		and	r3, r3, #255
 3681 0710 0312A0E1 		mov	r1, r3, asl #4
 3682 0714 14329FE5 		ldr	r3, .L39+32
 3683 0718 0030D3E5 		ldrb	r3, [r3, #0]
 3684 071c FF3003E2 		and	r3, r3, #255
 3685 0720 033081E0 		add	r3, r1, r3
 3686 0724 8330A0E1 		mov	r3, r3, asl #1
 3687 0728 033082E0 		add	r3, r2, r3
 3688 072c 0300A0E1 		mov	r0, r3
 3689 0730 90FEFFEB 		bl	celda_limpiar_error
 186:../button.c   ****                                         celda_poner_valor(&cuadricula[fila][columna], valor);
 3690              		.loc 1 186 0
 3691 0734 DC319FE5 		ldr	r3, .L39+8
 3692 0738 003093E5 		ldr	r3, [r3, #0]
 3693 073c 0320A0E1 		mov	r2, r3
 3694 0740 E4319FE5 		ldr	r3, .L39+28
 3695 0744 0030D3E5 		ldrb	r3, [r3, #0]
 3696 0748 FF3003E2 		and	r3, r3, #255
 3697 074c 0312A0E1 		mov	r1, r3, asl #4
 3698 0750 D8319FE5 		ldr	r3, .L39+32
 3699 0754 0030D3E5 		ldrb	r3, [r3, #0]
 3700 0758 FF3003E2 		and	r3, r3, #255
 3701 075c 033081E0 		add	r3, r1, r3
 3702 0760 8330A0E1 		mov	r3, r3, asl #1
 3703 0764 032082E0 		add	r2, r2, r3
 3704 0768 C4319FE5 		ldr	r3, .L39+36
 3705 076c 0030D3E5 		ldrb	r3, [r3, #0]
 3706 0770 FF3003E2 		and	r3, r3, #255
 3707 0774 0200A0E1 		mov	r0, r2
 3708 0778 0310A0E1 		mov	r1, r3
 3709 077c 1FFEFFEB 		bl	celda_poner_valor
 187:../button.c   ****                                         
 188:../button.c   ****                                         /* Decidir si propagar o actualizar según el caso */
 189:../button.c   ****                                         if (valor_previo != 0)
 3710              		.loc 1 189 0
 3711 0780 B0319FE5 		ldr	r3, .L39+40
 3712 0784 0030D3E5 		ldrb	r3, [r3, #0]
 3713 0788 FF3003E2 		and	r3, r3, #255
 3714 078c 000053E3 		cmp	r3, #0
 3715 0790 0700000A 		beq	.L31
 190:../button.c   ****                                         {
 191:../button.c   ****                                                 /* Se modificó un valor previo -> recalcular todo 
 192:../button.c   ****                                                 celdas_vacias = candidatos_actualizar_all(cuadricul
 3716              		.loc 1 192 0
 3717 0794 7C319FE5 		ldr	r3, .L39+8
 3718 0798 003093E5 		ldr	r3, [r3, #0]
 3719 079c 0300A0E1 		mov	r0, r3
 3720 07a0 FEFFFFEB 		bl	candidatos_actualizar_all
 3721 07a4 0020A0E1 		mov	r2, r0
 3722 07a8 6C319FE5 		ldr	r3, .L39+12
 3723 07ac 002083E5 		str	r2, [r3, #0]
 3724 07b0 0B0000EA 		b	.L32
 3725              	.L31:
 193:../button.c   ****                                         }
 194:../button.c   ****                                         else
 195:../button.c   ****                                         {
 196:../button.c   ****                                                 /* Celda vacía -> solo propagar el nuevo valor */
 197:../button.c   ****                                                 candidatos_propagar_arm(cuadricula, fila, columna);
 3726              		.loc 1 197 0
 3727 07b4 5C319FE5 		ldr	r3, .L39+8
 3728 07b8 001093E5 		ldr	r1, [r3, #0]
 3729 07bc 68319FE5 		ldr	r3, .L39+28
 3730 07c0 0030D3E5 		ldrb	r3, [r3, #0]
 3731 07c4 FF2003E2 		and	r2, r3, #255
 3732 07c8 60319FE5 		ldr	r3, .L39+32
 3733 07cc 0030D3E5 		ldrb	r3, [r3, #0]
 3734 07d0 FF3003E2 		and	r3, r3, #255
 3735 07d4 0100A0E1 		mov	r0, r1
 3736 07d8 0210A0E1 		mov	r1, r2
 3737 07dc 0320A0E1 		mov	r2, r3
 3738 07e0 FEFFFFEB 		bl	candidatos_propagar_arm
 3739              	.L32:
 198:../button.c   ****                                         }
 199:../button.c   ****                                         
 200:../button.c   ****                                         /* Actualizar la visualización del tablero */
 201:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3740              		.loc 1 201 0
 3741 07e4 2C319FE5 		ldr	r3, .L39+8
 3742 07e8 003093E5 		ldr	r3, [r3, #0]
 3743 07ec 0300A0E1 		mov	r0, r3
 3744 07f0 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 202:../button.c   ****                                         
 203:../button.c   ****                                         /* Volver a introducir fila */
 204:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 3745              		.loc 1 204 0
 3746 07f4 14319FE5 		ldr	r3, .L39
 3747 07f8 0120A0E3 		mov	r2, #1
 3748 07fc 0020C3E5 		strb	r2, [r3, #0]
 205:../button.c   ****                                         int_count = 9;  /* Iniciar en 9 para que al incrementar vay
 3749              		.loc 1 205 0
 3750 0800 18319FE5 		ldr	r3, .L39+16
 3751 0804 0920A0E3 		mov	r2, #9
 3752 0808 0020C3E5 		strb	r2, [r3, #0]
 206:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 3753              		.loc 1 206 0
 3754 080c 0F00A0E3 		mov	r0, #15
 3755 0810 FEFFFFEB 		bl	D8Led_symbol
 207:../button.c   ****                                 }
 208:../button.c   ****                                 else
 209:../button.c   ****                                 {
 210:../button.c   ****                                         /* No es candidato: marcar error y mostrar 'E' */
 211:../button.c   ****                                         celda_marcar_error(&cuadricula[fila][columna]);
 212:../button.c   ****                                         
 213:../button.c   ****                                         /* Actualizar la visualización del tablero */
 214:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 215:../button.c   ****                                         
 216:../button.c   ****                                         D8Led_symbol(14);  /* Mostrar 'E' de Error */
 217:../button.c   ****                                         
 218:../button.c   ****                                         /* Volver a introducir fila */
 219:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 220:../button.c   ****                                         int_count = 9;  /* Iniciar en 9 para que al incrementar vay
 221:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 222:../button.c   ****                                 }
 223:../button.c   ****                         }
 224:../button.c   ****                         break;
 3756              		.loc 1 224 0
 3757 0814 3A0000EA 		b	.L7
 3758              	.L30:
 211:../button.c   ****                                         celda_marcar_error(&cuadricula[fila][columna]);
 3759              		.loc 1 211 0
 3760 0818 F8309FE5 		ldr	r3, .L39+8
 3761 081c 003093E5 		ldr	r3, [r3, #0]
 3762 0820 0320A0E1 		mov	r2, r3
 3763 0824 00319FE5 		ldr	r3, .L39+28
 3764 0828 0030D3E5 		ldrb	r3, [r3, #0]
 3765 082c FF3003E2 		and	r3, r3, #255
 3766 0830 0312A0E1 		mov	r1, r3, asl #4
 3767 0834 F4309FE5 		ldr	r3, .L39+32
 3768 0838 0030D3E5 		ldrb	r3, [r3, #0]
 3769 083c FF3003E2 		and	r3, r3, #255
 3770 0840 033081E0 		add	r3, r1, r3
 3771 0844 8330A0E1 		mov	r3, r3, asl #1
 3772 0848 033082E0 		add	r3, r2, r3
 3773 084c 0300A0E1 		mov	r0, r3
 3774 0850 39FEFFEB 		bl	celda_marcar_error
 214:../button.c   ****                                         Sudoku_Actualizar_Tablero_Completo(cuadricula);
 3775              		.loc 1 214 0
 3776 0854 BC309FE5 		ldr	r3, .L39+8
 3777 0858 003093E5 		ldr	r3, [r3, #0]
 3778 085c 0300A0E1 		mov	r0, r3
 3779 0860 FEFFFFEB 		bl	Sudoku_Actualizar_Tablero_Completo
 216:../button.c   ****                                         D8Led_symbol(14);  /* Mostrar 'E' de Error */
 3780              		.loc 1 216 0
 3781 0864 0E00A0E3 		mov	r0, #14
 3782 0868 FEFFFFEB 		bl	D8Led_symbol
 219:../button.c   ****                                         estado_juego = INTRODUCIR_FILA;
 3783              		.loc 1 219 0
 3784 086c 9C309FE5 		ldr	r3, .L39
 3785 0870 0120A0E3 		mov	r2, #1
 3786 0874 0020C3E5 		strb	r2, [r3, #0]
 220:../button.c   ****                                         int_count = 9;  /* Iniciar en 9 para que al incrementar vay
 3787              		.loc 1 220 0
 3788 0878 A0309FE5 		ldr	r3, .L39+16
 3789 087c 0920A0E3 		mov	r2, #9
 3790 0880 0020C3E5 		strb	r2, [r3, #0]
 221:../button.c   ****                                         D8Led_symbol(15);  /* Mostrar 'F' de Fila */
 3791              		.loc 1 221 0
 3792 0884 0F00A0E3 		mov	r0, #15
 3793 0888 FEFFFFEB 		bl	D8Led_symbol
 3794              		.loc 1 224 0
 3795 088c 1C0000EA 		b	.L7
 3796              	.L15:
 225:../button.c   ****                 
 226:../button.c   ****                 case PARTIDA_TERMINADA:
 227:../button.c   ****                         /* Mostrar pantalla de despedida solo una vez */
 228:../button.c   ****                         if (!pantalla_mostrada)
 3797              		.loc 1 228 0
 3798 0890 8C309FE5 		ldr	r3, .L39+20
 3799 0894 0030D3E5 		ldrb	r3, [r3, #0]
 3800 0898 FF3003E2 		and	r3, r3, #255
 3801 089c 000053E3 		cmp	r3, #0
 3802 08a0 0700001A 		bne	.L34
 229:../button.c   ****                         {
 230:../button.c   ****                                 /* Usar la función existente de lcd.c */
 231:../button.c   ****                                 Sudoku_Pantalla_Final(tiempo_final);
 3803              		.loc 1 231 0
 3804 08a4 7C309FE5 		ldr	r3, .L39+24
 3805 08a8 003093E5 		ldr	r3, [r3, #0]
 3806 08ac 0300A0E1 		mov	r0, r3
 3807 08b0 FEFFFFEB 		bl	Sudoku_Pantalla_Final
 232:../button.c   ****                                 
 233:../button.c   ****                                 pantalla_mostrada = 1;
 3808              		.loc 1 233 0
 3809 08b4 68309FE5 		ldr	r3, .L39+20
 3810 08b8 0120A0E3 		mov	r2, #1
 3811 08bc 0020C3E5 		strb	r2, [r3, #0]
 234:../button.c   ****                         }
 235:../button.c   ****                         else
 236:../button.c   ****                         {
 237:../button.c   ****                                 /* Cualquier botón después de mostrar pantalla final reinicia el 
 238:../button.c   ****                                 /* Mostrar pantalla inicial */
 239:../button.c   ****                                 Sudoku_Pantalla_Inicial();
 240:../button.c   ****                                 
 241:../button.c   ****                                 /* Volver al estado inicial */
 242:../button.c   ****                                 estado_juego = ESPERANDO_INICIO;
 243:../button.c   ****                                 int_count = 0;
 244:../button.c   ****                                 pantalla_mostrada = 0;
 245:../button.c   ****                         }
 246:../button.c   ****                         break;
 3812              		.loc 1 246 0
 3813 08c0 0F0000EA 		b	.L7
 3814              	.L34:
 239:../button.c   ****                                 Sudoku_Pantalla_Inicial();
 3815              		.loc 1 239 0
 3816 08c4 FEFFFFEB 		bl	Sudoku_Pantalla_Inicial
 242:../button.c   ****                                 estado_juego = ESPERANDO_INICIO;
 3817              		.loc 1 242 0
 3818 08c8 40309FE5 		ldr	r3, .L39
 3819 08cc 0020A0E3 		mov	r2, #0
 3820 08d0 0020C3E5 		strb	r2, [r3, #0]
 243:../button.c   ****                                 int_count = 0;
 3821              		.loc 1 243 0
 3822 08d4 44309FE5 		ldr	r3, .L39+16
 3823 08d8 0020A0E3 		mov	r2, #0
 3824 08dc 0020C3E5 		strb	r2, [r3, #0]
 244:../button.c   ****                                 pantalla_mostrada = 0;
 3825              		.loc 1 244 0
 3826 08e0 3C309FE5 		ldr	r3, .L39+20
 3827 08e4 0020A0E3 		mov	r2, #0
 3828 08e8 0020C3E5 		strb	r2, [r3, #0]
 3829              		.loc 1 246 0
 3830 08ec 040000EA 		b	.L7
 3831              	.L36:
  95:../button.c   ****                         break;
 3832              		.loc 1 95 0
 3833 08f0 0000A0E1 		mov	r0, r0	@ nop
 3834 08f4 020000EA 		b	.L7
 3835              	.L37:
 116:../button.c   ****                         break;
 3836              		.loc 1 116 0
 3837 08f8 0000A0E1 		mov	r0, r0	@ nop
 3838 08fc 000000EA 		b	.L7
 3839              	.L38:
 154:../button.c   ****                         break;
 3840              		.loc 1 154 0
 3841 0900 0000A0E1 		mov	r0, r0	@ nop
 3842              	.L7:
 247:../button.c   ****         }
 248:../button.c   **** }
 3843              		.loc 1 248 0
 3844 0904 0CD04BE2 		sub	sp, fp, #12
 3845 0908 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3846 090c 1EFF2FE1 		bx	lr
 3847              	.L40:
 3848              		.align	2
 3849              	.L39:
 3850 0910 00000000 		.word	estado_juego
 3851 0914 08000000 		.word	tiempo_inicio
 3852 0918 00000000 		.word	cuadricula
 3853 091c 00000000 		.word	celdas_vacias
 3854 0920 01000000 		.word	int_count
 3855 0924 06000000 		.word	pantalla_mostrada
 3856 0928 0C000000 		.word	tiempo_final
 3857 092c 02000000 		.word	fila
 3858 0930 03000000 		.word	columna
 3859 0934 04000000 		.word	valor
 3860 0938 05000000 		.word	valor_previo
 3861              		.cfi_endproc
 3862              	.LFE7:
 3864              		.align	2
 3865              		.global	Eint4567_ISR
 3867              	Eint4567_ISR:
 3868              	.LFB8:
 249:../button.c   **** 
 250:../button.c   **** /* declaración de función que es rutina de servicio de interrupción
 251:../button.c   ****  * https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html */
 252:../button.c   **** void Eint4567_ISR(void) __attribute__((interrupt("IRQ")));
 253:../button.c   **** 
 254:../button.c   **** /*--- código de funciones ---*/
 255:../button.c   **** void Eint4567_ISR(void)
 256:../button.c   **** {
 3869              		.loc 1 256 0
 3870              		.cfi_startproc
 3871              		@ Interrupt Service Routine.
 3872              		@ args = 0, pretend = 0, frame = 8
 3873              		@ frame_needed = 1, uses_anonymous_args = 0
 3874 093c 04C02DE5 		str	ip, [sp, #-4]!
 3875 0940 0DC0A0E1 		mov	ip, sp
 3876              	.LCFI14:
 3877              		.cfi_def_cfa_register 12
 3878 0944 0FD82DE9 		stmfd	sp!, {r0, r1, r2, r3, fp, ip, lr, pc}
 3879 0948 04B04CE2 		sub	fp, ip, #4
 3880              		.cfi_offset 14, -8
 3881              		.cfi_offset 13, -12
 3882              		.cfi_offset 11, -16
 3883              		.cfi_offset 3, -20
 3884              		.cfi_offset 2, -24
 3885              		.cfi_offset 1, -28
 3886              		.cfi_offset 0, -32
 3887              	.LCFI15:
 3888              		.cfi_def_cfa 11, 4
 3889 094c 08D04DE2 		sub	sp, sp, #8
 257:../button.c   ****         /* Identificar la interrupción (hay dos pulsadores) */
 258:../button.c   ****         unsigned int pending = rEXTINTPND & 0xF;
 3890              		.loc 1 258 0
 3891 0950 8C309FE5 		ldr	r3, .L45
 3892 0954 003093E5 		ldr	r3, [r3, #0]
 3893 0958 0F3003E2 		and	r3, r3, #15
 3894 095c 24300BE5 		str	r3, [fp, #-36]
 259:../button.c   ****         uint8_t boton_id = 0;
 3895              		.loc 1 259 0
 3896 0960 0030A0E3 		mov	r3, #0
 3897 0964 1D304BE5 		strb	r3, [fp, #-29]
 260:../button.c   **** 
 261:../button.c   ****         if (pending & 0x4)
 3898              		.loc 1 261 0
 3899 0968 24301BE5 		ldr	r3, [fp, #-36]
 3900 096c 043003E2 		and	r3, r3, #4
 3901 0970 000053E3 		cmp	r3, #0
 3902 0974 0200000A 		beq	.L42
 262:../button.c   ****         {
 263:../button.c   ****                 boton_id = EVENTO_BOTON_IZQUIERDO;
 3903              		.loc 1 263 0
 3904 0978 0430A0E3 		mov	r3, #4
 3905 097c 1D304BE5 		strb	r3, [fp, #-29]
 3906 0980 050000EA 		b	.L43
 3907              	.L42:
 264:../button.c   ****         }
 265:../button.c   ****         else if (pending & 0x8)
 3908              		.loc 1 265 0
 3909 0984 24301BE5 		ldr	r3, [fp, #-36]
 3910 0988 083003E2 		and	r3, r3, #8
 3911 098c 000053E3 		cmp	r3, #0
 3912 0990 0100000A 		beq	.L43
 266:../button.c   ****         {
 267:../button.c   ****                 boton_id = EVENTO_BOTON_DERECHO;
 3913              		.loc 1 267 0
 3914 0994 0830A0E3 		mov	r3, #8
 3915 0998 1D304BE5 		strb	r3, [fp, #-29]
 3916              	.L43:
 268:../button.c   ****         }
 269:../button.c   **** 
 270:../button.c   ****         if (boton_id != 0U)
 3917              		.loc 1 270 0
 3918 099c 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 3919 09a0 000053E3 		cmp	r3, #0
 3920 09a4 0200000A 		beq	.L44
 271:../button.c   ****         {
 272:../button.c   ****                 /* No registrar la pulsación inicial, solo las confirmadas */
 273:../button.c   **** 
 274:../button.c   ****                 /* Iniciar la máquina de antirrebotes. Si está ocupada, no hacer nada */
 275:../button.c   ****                 timer3_start_antirrebote(boton_id);
 3921              		.loc 1 275 0
 3922 09a8 1D305BE5 		ldrb	r3, [fp, #-29]	@ zero_extendqisi2
 3923 09ac 0300A0E1 		mov	r0, r3
 3924 09b0 FEFFFFEB 		bl	timer3_start_antirrebote
 3925              	.L44:
 276:../button.c   ****         }
 277:../button.c   **** 
 278:../button.c   ****         /* Finalizar ISR */
 279:../button.c   ****         rEXTINTPND = 0xf;                               // borra los bits en EXTINTPND
 3926              		.loc 1 279 0
 3927 09b4 28309FE5 		ldr	r3, .L45
 3928 09b8 0F20A0E3 		mov	r2, #15
 3929 09bc 002083E5 		str	r2, [r3, #0]
 280:../button.c   ****         rI_ISPC   |= BIT_EINT4567;              // borra el bit pendiente en INTPND
 3930              		.loc 1 280 0
 3931 09c0 20309FE5 		ldr	r3, .L45+4
 3932 09c4 1C209FE5 		ldr	r2, .L45+4
 3933 09c8 002092E5 		ldr	r2, [r2, #0]
 3934 09cc 022682E3 		orr	r2, r2, #2097152
 3935 09d0 002083E5 		str	r2, [r3, #0]
 281:../button.c   **** }
 3936              		.loc 1 281 0
 3937 09d4 1CD04BE2 		sub	sp, fp, #28
 3938 09d8 0F689DE8 		ldmfd	sp, {r0, r1, r2, r3, fp, sp, lr}
 3939 09dc 04C09DE4 		ldmfd	sp!, {ip}
 3940 09e0 04F05EE2 		subs	pc, lr, #4
 3941              	.L46:
 3942              		.align	2
 3943              	.L45:
 3944 09e4 5400D201 		.word	30539860
 3945 09e8 2400E001 		.word	31457316
 3946              		.cfi_endproc
 3947              	.LFE8:
 3949              		.align	2
 3950              		.global	Sudoku_Partida_Terminada
 3952              	Sudoku_Partida_Terminada:
 3953              	.LFB9:
 282:../button.c   **** /* Función para consultar si la partida está terminada */
 283:../button.c   **** int Sudoku_Partida_Terminada(void)
 284:../button.c   **** {
 3954              		.loc 1 284 0
 3955              		.cfi_startproc
 3956              		@ Function supports interworking.
 3957              		@ args = 0, pretend = 0, frame = 0
 3958              		@ frame_needed = 1, uses_anonymous_args = 0
 3959 09ec 0DC0A0E1 		mov	ip, sp
 3960              	.LCFI16:
 3961              		.cfi_def_cfa_register 12
 3962 09f0 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 3963 09f4 04B04CE2 		sub	fp, ip, #4
 3964              		.cfi_offset 14, -8
 3965              		.cfi_offset 13, -12
 3966              		.cfi_offset 11, -16
 3967              	.LCFI17:
 3968              		.cfi_def_cfa 11, 4
 285:../button.c   **** 	return (estado_juego == PARTIDA_TERMINADA);
 3969              		.loc 1 285 0
 3970 09f8 20309FE5 		ldr	r3, .L48
 3971 09fc 0030D3E5 		ldrb	r3, [r3, #0]
 3972 0a00 FF3003E2 		and	r3, r3, #255
 3973 0a04 070053E3 		cmp	r3, #7
 3974 0a08 0030A013 		movne	r3, #0
 3975 0a0c 0130A003 		moveq	r3, #1
 286:../button.c   **** }
 3976              		.loc 1 286 0
 3977 0a10 0300A0E1 		mov	r0, r3
 3978 0a14 0CD04BE2 		sub	sp, fp, #12
 3979 0a18 00689DE8 		ldmfd	sp, {fp, sp, lr}
 3980 0a1c 1EFF2FE1 		bx	lr
 3981              	.L49:
 3982              		.align	2
 3983              	.L48:
 3984 0a20 00000000 		.word	estado_juego
 3985              		.cfi_endproc
 3986              	.LFE9:
 3988              		.align	2
 3989              		.global	Sudoku_Juego_En_Progreso
 3991              	Sudoku_Juego_En_Progreso:
 3992              	.LFB10:
 287:../button.c   **** 
 288:../button.c   **** /* Función para consultar si el juego está en progreso */
 289:../button.c   **** int Sudoku_Juego_En_Progreso(void)
 290:../button.c   **** {
 3993              		.loc 1 290 0
 3994              		.cfi_startproc
 3995              		@ Function supports interworking.
 3996              		@ args = 0, pretend = 0, frame = 0
 3997              		@ frame_needed = 1, uses_anonymous_args = 0
 3998 0a24 0DC0A0E1 		mov	ip, sp
 3999              	.LCFI18:
 4000              		.cfi_def_cfa_register 12
 4001 0a28 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4002 0a2c 04B04CE2 		sub	fp, ip, #4
 4003              		.cfi_offset 14, -8
 4004              		.cfi_offset 13, -12
 4005              		.cfi_offset 11, -16
 4006              	.LCFI19:
 4007              		.cfi_def_cfa 11, 4
 291:../button.c   **** 	return (estado_juego != ESPERANDO_INICIO && estado_juego != PARTIDA_TERMINADA);
 4008              		.loc 1 291 0
 4009 0a30 3C309FE5 		ldr	r3, .L53
 4010 0a34 0030D3E5 		ldrb	r3, [r3, #0]
 4011 0a38 FF3003E2 		and	r3, r3, #255
 4012 0a3c 000053E3 		cmp	r3, #0
 4013 0a40 0600000A 		beq	.L51
 4014              		.loc 1 291 0 is_stmt 0 discriminator 1
 4015 0a44 28309FE5 		ldr	r3, .L53
 4016 0a48 0030D3E5 		ldrb	r3, [r3, #0]
 4017 0a4c FF3003E2 		and	r3, r3, #255
 4018 0a50 070053E3 		cmp	r3, #7
 4019 0a54 0100000A 		beq	.L51
 4020 0a58 0130A0E3 		mov	r3, #1
 4021 0a5c 000000EA 		b	.L52
 4022              	.L51:
 4023              		.loc 1 291 0 discriminator 2
 4024 0a60 0030A0E3 		mov	r3, #0
 4025              	.L52:
 292:../button.c   **** }
 4026              		.loc 1 292 0 is_stmt 1 discriminator 3
 4027 0a64 0300A0E1 		mov	r0, r3
 4028 0a68 0CD04BE2 		sub	sp, fp, #12
 4029 0a6c 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4030 0a70 1EFF2FE1 		bx	lr
 4031              	.L54:
 4032              		.align	2
 4033              	.L53:
 4034 0a74 00000000 		.word	estado_juego
 4035              		.cfi_endproc
 4036              	.LFE10:
 4038              		.align	2
 4039              		.global	Sudoku_Obtener_Tiempo_Inicio
 4041              	Sudoku_Obtener_Tiempo_Inicio:
 4042              	.LFB11:
 293:../button.c   **** 
 294:../button.c   **** /* Función para obtener el tiempo de inicio de la partida */
 295:../button.c   **** unsigned int Sudoku_Obtener_Tiempo_Inicio(void)
 296:../button.c   **** {
 4043              		.loc 1 296 0
 4044              		.cfi_startproc
 4045              		@ Function supports interworking.
 4046              		@ args = 0, pretend = 0, frame = 0
 4047              		@ frame_needed = 1, uses_anonymous_args = 0
 4048 0a78 0DC0A0E1 		mov	ip, sp
 4049              	.LCFI20:
 4050              		.cfi_def_cfa_register 12
 4051 0a7c 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4052 0a80 04B04CE2 		sub	fp, ip, #4
 4053              		.cfi_offset 14, -8
 4054              		.cfi_offset 13, -12
 4055              		.cfi_offset 11, -16
 4056              	.LCFI21:
 4057              		.cfi_def_cfa 11, 4
 297:../button.c   **** 	return tiempo_inicio;
 4058              		.loc 1 297 0
 4059 0a84 10309FE5 		ldr	r3, .L56
 4060 0a88 003093E5 		ldr	r3, [r3, #0]
 298:../button.c   **** }
 4061              		.loc 1 298 0
 4062 0a8c 0300A0E1 		mov	r0, r3
 4063 0a90 0CD04BE2 		sub	sp, fp, #12
 4064 0a94 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4065 0a98 1EFF2FE1 		bx	lr
 4066              	.L57:
 4067              		.align	2
 4068              	.L56:
 4069 0a9c 08000000 		.word	tiempo_inicio
 4070              		.cfi_endproc
 4071              	.LFE11:
 4073              		.align	2
 4074              		.global	Eint4567_init
 4076              	Eint4567_init:
 4077              	.LFB12:
 299:../button.c   **** void Eint4567_init(void)
 300:../button.c   **** {
 4078              		.loc 1 300 0
 4079              		.cfi_startproc
 4080              		@ Function supports interworking.
 4081              		@ args = 0, pretend = 0, frame = 0
 4082              		@ frame_needed = 1, uses_anonymous_args = 0
 4083 0aa0 0DC0A0E1 		mov	ip, sp
 4084              	.LCFI22:
 4085              		.cfi_def_cfa_register 12
 4086 0aa4 00D82DE9 		stmfd	sp!, {fp, ip, lr, pc}
 4087 0aa8 04B04CE2 		sub	fp, ip, #4
 4088              		.cfi_offset 14, -8
 4089              		.cfi_offset 13, -12
 4090              		.cfi_offset 11, -16
 4091              	.LCFI23:
 4092              		.cfi_def_cfa 11, 4
 301:../button.c   ****         /* Inicializar el temporizador dedicado a la eliminación de rebotes */
 302:../button.c   ****         timer3_init(boton_confirmado);
 4093              		.loc 1 302 0
 4094 0aac AC009FE5 		ldr	r0, .L59
 4095 0ab0 FEFFFFEB 		bl	timer3_init
 303:../button.c   **** 
 304:../button.c   ****         /* Configuracion del controlador de interrupciones. Estos registros están definidos en 44b
 305:../button.c   ****         rI_ISPC    = 0x3ffffff;         // Borra INTPND escribiendo 1s en I_ISPC
 4096              		.loc 1 305 0
 4097 0ab4 A8309FE5 		ldr	r3, .L59+4
 4098 0ab8 3F23E0E3 		mvn	r2, #-67108864
 4099 0abc 002083E5 		str	r2, [r3, #0]
 306:../button.c   ****         rEXTINTPND = 0xf;               // Borra EXTINTPND escribiendo 1s en el propio registro
 4100              		.loc 1 306 0
 4101 0ac0 A0309FE5 		ldr	r3, .L59+8
 4102 0ac4 0F20A0E3 		mov	r2, #15
 4103 0ac8 002083E5 		str	r2, [r3, #0]
 307:../button.c   ****         rINTMOD    = 0x0;               // Configura las lineas como de tipo IRQ
 4104              		.loc 1 307 0
 4105 0acc 98309FE5 		ldr	r3, .L59+12
 4106 0ad0 0020A0E3 		mov	r2, #0
 4107 0ad4 002083E5 		str	r2, [r3, #0]
 308:../button.c   ****         rINTCON    = 0x1;               // Habilita int. vectorizadas y la linea IRQ (FIQ no)
 4108              		.loc 1 308 0
 4109 0ad8 1E36A0E3 		mov	r3, #31457280
 4110 0adc 0120A0E3 		mov	r2, #1
 4111 0ae0 002083E5 		str	r2, [r3, #0]
 309:../button.c   ****         rINTMSK    &= ~(BIT_EINT4567);  // habilitamos interrupcion linea eint4567 en vector de mas
 4112              		.loc 1 309 0
 4113 0ae4 84309FE5 		ldr	r3, .L59+16
 4114 0ae8 80209FE5 		ldr	r2, .L59+16
 4115 0aec 002092E5 		ldr	r2, [r2, #0]
 4116 0af0 0226C2E3 		bic	r2, r2, #2097152
 4117 0af4 002083E5 		str	r2, [r3, #0]
 310:../button.c   **** 
 311:../button.c   ****         /* Establece la rutina de servicio para Eint4567 */
 312:../button.c   ****         pISR_EINT4567 = (int) Eint4567_ISR;
 4118              		.loc 1 312 0
 4119 0af8 74309FE5 		ldr	r3, .L59+20
 4120 0afc 74209FE5 		ldr	r2, .L59+24
 4121 0b00 002083E5 		str	r2, [r3, #0]
 313:../button.c   **** 
 314:../button.c   ****         /* Configuracion del puerto G */
 315:../button.c   ****         rPCONG  = 0xffff;                       // Establece la funcion de los pines (EINT0-7)
 4122              		.loc 1 315 0
 4123 0b04 70309FE5 		ldr	r3, .L59+28
 4124 0b08 70209FE5 		ldr	r2, .L59+32
 4125 0b0c 002083E5 		str	r2, [r3, #0]
 316:../button.c   ****         rPUPG   = 0x0;                  // Habilita el "pull up" del puerto
 4126              		.loc 1 316 0
 4127 0b10 6C309FE5 		ldr	r3, .L59+36
 4128 0b14 0020A0E3 		mov	r2, #0
 4129 0b18 002083E5 		str	r2, [r3, #0]
 317:../button.c   ****         rEXTINT = rEXTINT | 0x22222222;   // Configura las lineas de int. como de flanco de bajada
 4130              		.loc 1 317 0
 4131 0b1c 64209FE5 		ldr	r2, .L59+40
 4132 0b20 60309FE5 		ldr	r3, .L59+40
 4133 0b24 001093E5 		ldr	r1, [r3, #0]
 4134 0b28 5C309FE5 		ldr	r3, .L59+44
 4135 0b2c 033081E1 		orr	r3, r1, r3
 4136 0b30 003082E5 		str	r3, [r2, #0]
 318:../button.c   **** 
 319:../button.c   ****         /* Por precaucion, se vuelven a borrar los bits de INTPND y EXTINTPND */
 320:../button.c   ****         rEXTINTPND = 0xf;                               // borra los bits en EXTINTPND
 4137              		.loc 1 320 0
 4138 0b34 2C309FE5 		ldr	r3, .L59+8
 4139 0b38 0F20A0E3 		mov	r2, #15
 4140 0b3c 002083E5 		str	r2, [r3, #0]
 321:../button.c   ****         rI_ISPC   |= BIT_EINT4567;              // borra el bit pendiente en INTPND
 4141              		.loc 1 321 0
 4142 0b40 1C309FE5 		ldr	r3, .L59+4
 4143 0b44 18209FE5 		ldr	r2, .L59+4
 4144 0b48 002092E5 		ldr	r2, [r2, #0]
 4145 0b4c 022682E3 		orr	r2, r2, #2097152
 4146 0b50 002083E5 		str	r2, [r3, #0]
 322:../button.c   **** }
 4147              		.loc 1 322 0
 4148 0b54 0CD04BE2 		sub	sp, fp, #12
 4149 0b58 00689DE8 		ldmfd	sp, {fp, sp, lr}
 4150 0b5c 1EFF2FE1 		bx	lr
 4151              	.L60:
 4152              		.align	2
 4153              	.L59:
 4154 0b60 00000000 		.word	boton_confirmado
 4155 0b64 2400E001 		.word	31457316
 4156 0b68 5400D201 		.word	30539860
 4157 0b6c 0800E001 		.word	31457288
 4158 0b70 0C00E001 		.word	31457292
 4159 0b74 74FF7F0C 		.word	209715060
 4160 0b78 00000000 		.word	Eint4567_ISR
 4161 0b7c 4000D201 		.word	30539840
 4162 0b80 FFFF0000 		.word	65535
 4163 0b84 4800D201 		.word	30539848
 4164 0b88 5000D201 		.word	30539856
 4165 0b8c 22222222 		.word	572662306
 4166              		.cfi_endproc
 4167              	.LFE12:
 4169              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 button.c
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:2979   .text:00000000 $a
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:2981   .text:00000000 celda_poner_valor
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3032   .text:00000078 celda_leer_valor
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3067   .text:000000b0 celda_es_candidato
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3108   .text:00000100 celda_es_pista
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3144   .text:0000013c celda_marcar_error
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3180   .text:00000178 celda_limpiar_error
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3215   .bss:00000000 estado_juego
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3216   .bss:00000000 $d
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3217   .bss:00000001 int_count
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3219   .bss:00000002 fila
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3221   .bss:00000003 columna
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3223   .bss:00000004 valor
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3225   .bss:00000005 valor_previo
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3227   .bss:00000006 pantalla_mostrada
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3230   .bss:00000008 tiempo_inicio
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3233   .bss:0000000c tiempo_final
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3238   .text:000001b4 boton_confirmado
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3277   .text:0000020c $d
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3287   .text:0000022c $a
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3850   .text:00000910 $d
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3864   .text:0000093c $a
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3867   .text:0000093c Eint4567_ISR
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3944   .text:000009e4 $d
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3949   .text:000009ec $a
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3952   .text:000009ec Sudoku_Partida_Terminada
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3984   .text:00000a20 $d
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3988   .text:00000a24 $a
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:3991   .text:00000a24 Sudoku_Juego_En_Progreso
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:4034   .text:00000a74 $d
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:4038   .text:00000a78 $a
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:4041   .text:00000a78 Sudoku_Obtener_Tiempo_Inicio
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:4069   .text:00000a9c $d
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:4073   .text:00000aa0 $a
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:4076   .text:00000aa0 Eint4567_init
C:\Users\jaime\AppData\Local\Temp\cczx6EQH.s:4154   .text:00000b60 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
timer2_count
cola_depuracion
candidatos_actualizar_all
Sudoku_Dibujar_Tablero
Sudoku_Actualizar_Tablero_Completo
D8Led_symbol
candidatos_propagar_arm
Sudoku_Pantalla_Final
Sudoku_Pantalla_Inicial
cuadricula
celdas_vacias
timer3_start_antirrebote
timer3_init
